<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Sunday"><link rel="alternative" href="/atom.xml" title="I'm Sunday" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>service - I'm Sunday</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">I'm Sunday</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-03-31T06:44:35.000Z">March 31, 2018</time><h1 class="post__title"><a href="/2018/03/31/service/">service</a></h1><div class="post__main echo"><blockquote>
<p>Android的四大组件之一，Android最默默无闻的组件，我觉得也是最难掌握的一个组件，自己了解的不是很好，所以在这纯搬运了大佬的文章。</p>
</blockquote>
<h2 id="第一篇讲了service的创建和两种启动方法"><a href="#第一篇讲了service的创建和两种启动方法" class="headerlink" title="第一篇讲了service的创建和两种启动方法"></a>第一篇讲了service的创建和两种启动方法</h2><p>附上链接<br><a href="https://blog.csdn.net/luoyanglizi/article/details/51586437" target="_blank" rel="noopener"> Android中的Service：默默的奉献者 (1)</a></p>
<h2 id="使用bindservice启动时的细节实现"><a href="#使用bindservice启动时的细节实现" class="headerlink" title="使用bindservice启动时的细节实现"></a>使用bindservice启动时的细节实现</h2><p>附上链接<br><a href="https://blog.csdn.net/luoyanglizi/article/details/51594016" target="_blank" rel="noopener">Android中的Service：Binder，Messenger，AIDL（2） </a></p>
<h2 id="将我的一些困惑和理解写在下面"><a href="#将我的一些困惑和理解写在下面" class="headerlink" title="将我的一些困惑和理解写在下面"></a>将我的一些困惑和理解写在下面</h2><h3 id="关于Service的实例化"><a href="#关于Service的实例化" class="headerlink" title="关于Service的实例化"></a>关于Service的实例化</h3><p>当我们用下面代码启动一个服务时，如果在实例化一个启动该Service的Intent，并再次调用startService，则这个服务不会再被创建，即不会再执行onCreate,只会调用onStartCommand。onCreate在第一次调用startService之后被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,service.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure></p>
<p>停止服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(intent);</span><br></pre></td></tr></table></figure></p>
<h4 id="onBinder的用法"><a href="#onBinder的用法" class="headerlink" title="onBinder的用法"></a>onBinder的用法</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>客户端原则上来讲调用bindService()方法就可以了，然而事实并没有这么简单。原因就出在bindService()这个方法身上。下面我们来详细的了解一下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以看到，bindService()方法需要三个参数，第一个是一个intent，我们都很熟悉——它和startService()里面那个intent是一样的，用来指定启动哪一个service以及传递一些数据过去。第二个参数可能就有点陌生了，这是个啥？这是实现客户端与服务端通信的一个关键类。要想实现它，就必须重写两个回调方法：onServiceConnected()以及onServiceDisconnected()，而我们可以通过这两个回调方法得到服务端里面的IBinder对象，从而达到通信的目的(下文对此会有更加详细的介绍)。下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ServiceDemo mService;</span><br><span class="line"><span class="comment">//BinderDemo是在ServiceDemo里面的一个继承了Binder的内部类，这是一种得到IBinder接口的方式</span></span><br><span class="line"><span class="comment">//下文会有详述</span></span><br><span class="line">ServiceDemo.BinderDemo mBinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当系统调用 onServiceConnected() 回调方法时，我们可以使用接口定义的方法开始调用服务。</span></span><br><span class="line">        mBinder = (ServiceDemo.BinderDemo) service;</span><br><span class="line">        <span class="comment">//getService()是BinderDemo中的一个方法</span></span><br><span class="line">        mService = mBinder.getService();</span><br><span class="line">        <span class="comment">//在此处可以利用得到的ServiceDemo对象调用该类中的构造方法</span></span><br><span class="line">        Log.d(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"onServiceConnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Android系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“绝对不会”调用该方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"onServiceDisconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子实现了一个比较普通的ServiceConnection的主要功能，我们可以通过它得到目标service的对象，然后可以调用其内的共有方法，实现客户端与服务端交互的目的。</p>
<p>bindService()方法的第三个参数是一个int值，还叫flag(这flag立的)，它是用来做什么的呢？它是一个指示绑定选项的标志，通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的服务。 其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。</p>
<p>ok，客户端的配置到这里就差不多搞定了，接下来看看服务端需要做些什么。</p>
<h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><blockquote>
<p>如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式：继承Binder类，使用Messenger类，使用AIDL。</p>
</blockquote>
<p><strong>1 继承Binder类</strong><br>它实现了IBinder接口，通过实现Binder类，我们的客户端可以直接通过这个类调用服务端的公有方法。另外，虽然从IPC的角度来讲，Binder是Android中的一种跨进程通信方式，但是其实一般service里面的Binder是不会涉及进程间通信的，所以其在这种情况下显得较为简单。</p>
<p>下面我们来看下通过继承Binder类实现客户端与服务端通信应该怎样做：</p>
<ul>
<li>在service类中，创建一个满足以下任一要求的Binder实例：<ul>
<li>包含客户端可调用的公共方法</li>
<li>返回当前Service实例，其中包含客户端可调用的公共方法</li>
<li>返回由当前service承载的其他类的实例，其中包含客户端可调用的公共方法</li>
</ul>
</li>
<li>在onBind()方法中返回这个Binder实例</li>
<li>在客户端中通过onServiceDisconnected()方法接收传过去的Binder实例，并通过它提供的方法进行后续操作</li>
</ul>
<p>可以看到，在使用这种方法进行客户端与服务端之间的交互是需要有一个强制类型转换的——在onServiceDisconnected()中获得一个经过转换的IBinder对象，我们必须将其转换为service类中的Binder实例的类型才能正确的调用其方法。而这强制类型转换其实就隐含了一个使用这种方法的条件：客户端和服务端应当在同一个进程中！不然在类型转换的时候也许会出现问题——在另一个进程中一定有这个Binder实例么？没有的话就不能完成强制类型转换。</p>
<p>下面是一个Google官方的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random mGenerator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class used for the client Binder.  Because we know this service always</span></span><br><span class="line"><span class="comment">     * runs in the same process as its clients, we don't need to deal with IPC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Return this instance of LocalService so clients can call public methods</span></span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么时候用startService什么时候用bindService"><a href="#什么时候用startService什么时候用bindService" class="headerlink" title="什么时候用startService什么时候用bindService?"></a>什么时候用startService什么时候用bindService?</h3><p>这个其实可以通过它们的特点很轻松的得到结论：它们之间的主要区别其实体现在两点，能否交互，以及生命周期。所以很显然的，startService适合那种启动之后不显式停止它就永远在后台运行，并且不需要客户端与服务端交互的service。比方说一条专门拿来存数据到本地数据库的service，它就一直在后台等着有别的组件startService，然后把拿到的数据存入数据库，这就显然是用startService做的事情。而bindService呢，就适合那种可以交互的，可以掌控它什么时候停什么时候开始的。另外，如果有IPC的需求，那当然bindService是必不可少的了。</p>
<p>我们在上一篇博文里讲过，其实在大多数情况下，startService和bindService都是相辅相成的，它们并不是孤立的存在。比方说我这个时候要做一个音乐播放器，那么后台播放是肯定要的吧？总不能手机一熄屏音乐也没了。另外，控制音乐也是要的吧？什么上一首下一首播放暂停什么的。这不就强强联合了么？当然要注意的是，在这两种启动方式同时存在去启动一个service的时候，service的生命周期会发生变化，必须从两种方法的角度看service均停止才能真正停止。</p>
<h3 id="关于IntentService"><a href="#关于IntentService" class="headerlink" title="关于IntentService"></a>关于IntentService</h3><p><a href="https://blog.csdn.net/iromkoear/article/details/63252665" target="_blank" rel="noopener">IntentService详解</a></p>
<h3 id="关于service的生命周期"><a href="#关于service的生命周期" class="headerlink" title="关于service的生命周期"></a>关于service的生命周期</h3><p> 如果是通过startService方法启动的服务，如果不在内部调用stopself或者不在外部调用stopService，只有当启动该服务的进程终止时，该服务才会结束。</p>
<p>如果通过bindService启动服务，可以通过unbindService方法解绑服务，服务即停止，或者当bindService的组件销毁时，该服务就会停止。</p>
<p><img src="/2018/03/31/service/lifecircle.png" alt="看图"></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Androd/">Androd</a></li></ul></footer></article><section class="reward"> <a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechatss.png" title="微信"></div></section><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 Sunday</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>