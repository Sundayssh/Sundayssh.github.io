<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JVMGC | I&#39;m Sunday</title>
  <meta name="author" content="Sunday">
  
  <meta name="description" content="关于垃圾回收机制，我们一般只关心下面两个问题。


什么时候回收
怎么回收


首先介绍一下Java中的四中引用

Java中的四种引用

强引用  不会被回收
弱引用  在内存不足时才会被回收
软引用  一旦触发了GC就会被回收
虚引用  没有用处的引用，被用来跟踪引用状态

例子：
123Car">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JVMGC"/>
  <meta property="og:site_name" content="I&#39;m Sunday"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="I&#39;m Sunday" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/avatar.png">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">I&#39;m Sunday</a></h1>
		    <h2><a href="/"></a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/node"><i class="fa fa-book"></i>Node.js</a>
		    		
		    		  <a href="/hexo"><i class="fa fa-book"></i>电子书</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href="/atom.xml"><i class="fa fa-rss"></i>订阅</a>
		    
		      <a href="/customization"><i class="fa fa-question-circle"></i>留言</a>
		    
		      <a href="/about"><i class="fa fa-user"></i>关于我</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-23T02:19:39.000Z"><a href="/2018/04/23/JVMGC/">2018-04-23</a></time>
        
  
    <h1 class="title">JVMGC</h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于什么时候回收"><span class="toc-text"><a href="#&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;" class="headerlink" title="&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;"></a>&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法"><span class="toc-text"><a href="#GC&#x7B97;&#x6CD5;" class="headerlink" title="GC&#x7B97;&#x6CD5;"></a>GC&#x7B97;&#x6CD5;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数算法（Reference-Counting-Collector）"><span class="toc-text"><a href="#&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference-Counting-Collector&#xFF09;" class="headerlink" title="&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference Counting Collector&#xFF09;"></a>&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference Counting Collector&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根搜索算法（Tracing-Collector）"><span class="toc-text"><a href="#&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing-Collector&#xFF09;" class="headerlink" title="&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing Collector&#xFF09;"></a>&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing Collector&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-清除法"><span class="toc-text"><a href="#&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;" class="headerlink" title="&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;"></a>&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记—整理算法（标记-压缩）"><span class="toc-text"><a href="#&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;" class="headerlink" title="&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;"></a>&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制算法"><span class="toc-text"><a href="#&#x590D;&#x5236;&#x7B97;&#x6CD5;" class="headerlink" title="&#x590D;&#x5236;&#x7B97;&#x6CD5;"></a>&#x590D;&#x5236;&#x7B97;&#x6CD5;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增量算法"><span class="toc-text"><a href="#&#x589E;&#x91CF;&#x7B97;&#x6CD5;" class="headerlink" title="&#x589E;&#x91CF;&#x7B97;&#x6CD5;"></a>&#x589E;&#x91CF;&#x7B97;&#x6CD5;</span></a></li></ol></li></ol>
    </div>

        <blockquote>
<p>关于垃圾回收机制，我们一般只关心下面两个问题。</p>
</blockquote>
<ul>
<li>什么时候回收</li>
<li>怎么回收</li>
</ul>
<blockquote>
<p>首先介绍一下Java中的四中引用</p>
</blockquote>
<p><strong>Java中的四种引用</strong></p>
<ol>
<li>强引用  不会被回收</li>
<li>弱引用  在内存不足时才会被回收</li>
<li>软引用  一旦触发了GC就会被回收</li>
<li>虚引用  没有用处的引用，被用来跟踪引用状态</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Car car=<span class="keyword">new</span> Car();</span><br><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference(Car)(car);</span><br></pre></td></tr></table></figure>
<p>这是一个弱引用的例子<br><br>weakCar 为newCar()的弱引用<br><br>这样可以取出弱引用的对象<br>Car car=weakCar</p>
<h3 id="关于什么时候回收"><a href="#关于什么时候回收" class="headerlink" title="关于什么时候回收"></a>关于什么时候回收</h3><p>垃圾回收用户来说是透明的，即我们不需要关心什么时候回收，怎样回收，当然我们也可以强制回收。</p>
<ol>
<li>当内存不足时，Jvm会自动回收</li>
<li>我们可以用System.gc()通知jvm进行垃圾回收，但是不一定会马上执行。</li>
</ol>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：</p>
<ol>
<li>找到所有存活对象</li>
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。</li>
</ol>
<p><strong>判断对象是否为垃圾</strong></p>
<h4 id="引用计数算法（Reference-Counting-Collector）"><a href="#引用计数算法（Reference-Counting-Collector）" class="headerlink" title="引用计数算法（Reference Counting Collector）"></a>引用计数算法（Reference Counting Collector）</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为0。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<p>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）。</p>
<p>缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。</p>
<h4 id="根搜索算法（Tracing-Collector）"><a href="#根搜索算法（Tracing-Collector）" class="headerlink" title="根搜索算法（Tracing Collector）"></a>根搜索算法（Tracing Collector）</h4><p>首先了解一个概念：根集</p>
<p>根集里面都包括什么：</p>
<ol>
<li>Java栈中的引用</li>
<li>本地方法栈JNI（Native方法）引用</li>
<li>方法区中的静态变量的引用</li>
<li>方法区中的常量的引用</li>
</ol>
<p>这种算法的基本思路：</p>
<ol>
<li>通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。</li>
<li>找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。</li>
<li>重复第二步</li>
<li>搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</li>
<li></li>
</ol>
<p>然后再标记可达对象：</p>
<p>首先，垃圾回收器将某些特殊的对象定义为GC根对象。所谓的GC根对象包括：</p>
<ol>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li>
<li>本地方法栈中JNI（Native方法）的引用对象</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>活跃线程</li>
</ol>
<p>接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。</p>
<p><strong>关于标记阶段有几个关键点是值得注意的：</strong></p>
<ol>
<li>开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。</li>
<li>暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。</li>
<li>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：<br>（1）如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法，当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。<br>（2）如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li>
</ol>
<p><strong>回收垃圾的算法</strong></p>
<h4 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h4><p> 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<br> 同时，Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。</p>
<p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。<br>缺点：会产生大量的内存碎片，如果现在有一个对象需要的内存大于所有的碎片，就会不停的出发gc，最后抛出oom。</p>
<h4 id="标记—整理算法（标记-压缩）"><a href="#标记—整理算法（标记-压缩）" class="headerlink" title="标记—整理算法（标记-压缩）"></a>标记—整理算法（标记-压缩）</h4><p>该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<p>优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p>
<p>缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p>
<p>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。一种典型的基于Coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。</p>
<p>优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）</p>
<p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p>
<h4 id="增量算法"><a href="#增量算法" class="headerlink" title="增量算法"></a>增量算法</h4><p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>优点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。</p>
<p>缺点：因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>

      
    </div>
    <footer>
      
        
        
  <div class="tags">
    <a href="/tags/Java/">Java</a>
  </div>

        
  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a><a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a><a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a><a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a><a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a></div>
  <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div></div></div>
      <aside id="sidebar" class="alignright">
        
           

        
          <div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/qrcode.jpg" alt="欢迎关注个人公众账号" style= "width: 100%">
    </ul>
</div>
        
          <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>

        
          
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://xiaoyun.farbox.com'>晓晓博客</a></li>
        
          <li class='link'><a href='http://www.ituring.com.cn/users/136808'>图灵社区</a></li>
        
      </ul>
  </div>


        
          
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">公元 2018 年</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">11</span></li></ul>
  </div>

        
      </aside>
      <div class="clearfix"></div>
    </div>
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2018 Sunday
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>

  <div>
    Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:, root:'calendar'});
    
    });
  </script>


<!-- 百度统计 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>