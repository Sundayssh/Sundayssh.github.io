<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Sunday"><link rel="alternative" href="/atom.xml" title="I'm Sunday" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>图的两种遍历算法 - I'm Sunday</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">I'm Sunday</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-12-19T16:00:00.000Z">December 20, 2017</time><h1 class="post__title"><a href="/2017/12/20/两种图的遍历算法/">图的两种遍历算法</a></h1><div class="post__main echo"><p>明天是英语课的模拟面试，今天看了一下题，发现有一题说，讲一下图的两种遍历方式，勾起了学习数据结构那段日子的回忆。<br><br><img src="/2017/12/20/两种图的遍历算法/tree.jpg" alt=""></p>
<p><strong>深度优先遍历</strong></p>
<p>很容易想到深度优先遍历是一种递归思想，即从图的顶点出发，向某个放下依次遍历顶点，直到该顶点没有左孩子（右孩子），然后再以该节点的右孩子（左孩子）为顶点，即对每个顶点都进行深度优先遍历。<br><br>所以顺序应该为0-&gt;1-&gt;3-&gt;7-&gt;4-&gt;2-&gt;5-&gt;6</p>
<p><strong>广度优先遍历</strong></p>
<p>广度优先遍历即一层一层地遍历，从顶点开始,将与该顶点相邻的结点全部访问后再访问下一层。<br><br>顺序为 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</p>
<p>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAX][MAX];    <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n;                  <span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> e;                  <span class="comment">//边数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MAX];          <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatMGraph</span><span class="params">(MGraph &amp;G)</span>    <span class="comment">//用引用作参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> s,t;                 <span class="comment">//存储顶点编号</span></span><br><span class="line">    <span class="keyword">int</span> v;                   <span class="comment">//存储边的权值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)       <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G.edges[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++)      <span class="comment">//对矩阵相邻的边赋权值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;s,&amp;t,&amp;v);   <span class="comment">//输入边的顶点编号以及权值</span></span><br><span class="line">        G.edges[s][t]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span>      <span class="comment">//深度优先搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);          <span class="comment">//访问结点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++)       <span class="comment">//访问与v相邻的未被访问过的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G.edges[v][i]!=<span class="number">0</span>&amp;&amp;visited[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS1</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span>   <span class="comment">//非递归实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);        <span class="comment">//访问初始结点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    s.push(v);              <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=s.top();          <span class="comment">//取栈顶顶点</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)  <span class="comment">//访问与顶点i相邻的顶点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.edges[i][j]!=<span class="number">0</span>&amp;&amp;visited[j]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);     <span class="comment">//访问</span></span><br><span class="line">                visited[j]=<span class="literal">true</span>;</span><br><span class="line">                s.push(j);           <span class="comment">//访问完后入栈</span></span><br><span class="line">                <span class="keyword">break</span>;               <span class="comment">//找到一个相邻未访问的顶点，访问之后则跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==G.n)                   <span class="comment">//如果与i相邻的顶点都被访问过，则将顶点i出栈</span></span><br><span class="line">            s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span>      <span class="comment">//广度优先搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;             <span class="comment">//STL模板中的queue</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    Q.push(v);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        i=Q.front();         <span class="comment">//取队首顶点</span></span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)   <span class="comment">//广度遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.edges[i][j]!=<span class="number">0</span>&amp;&amp;visited[j]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,j);</span><br><span class="line">                visited[j]=<span class="literal">true</span>;</span><br><span class="line">                Q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e;    <span class="comment">//建立的图的顶点数和边数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;e)==<span class="number">2</span>&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MGraph G;</span><br><span class="line">        G.n=n;</span><br><span class="line">        G.e=e;</span><br><span class="line">        creatMGraph(G);</span><br><span class="line">        DFS(G,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//    DFS1(G,0);</span></span><br><span class="line">    <span class="comment">//    printf("\n");</span></span><br><span class="line">    <span class="comment">//    BFS(G,0);</span></span><br><span class="line">    <span class="comment">//    printf("\n");</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/数据结构-C/">数据结构 C</a></li></ul></footer></article><section class="reward"> <a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechatss.png" title="微信"></div></section><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 Sunday</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>