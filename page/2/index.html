<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | I&#39;m Sunday</title>
  <meta name="author" content="Sunday">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="I&#39;m Sunday"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="I&#39;m Sunday" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/avatar.png">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">I&#39;m Sunday</a></h1>
		    <h2><a href="/"></a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/node"><i class="fa fa-book"></i>Node.js</a>
		    		
		    		  <a href="/hexo"><i class="fa fa-book"></i>电子书</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href="/atom.xml"><i class="fa fa-rss"></i>订阅</a>
		    
		      <a href="/customization"><i class="fa fa-question-circle"></i>留言</a>
		    
		      <a href="/about"><i class="fa fa-user"></i>关于我</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper">
    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-23T02:19:39.000Z"><a href="/2018/04/23/JVMGC/">2018-04-23</a></time>
        
  
    <h1 class="title"><a href="/2018/04/23/JVMGC/">JVMGC</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于什么时候回收"><span class="toc-text"><a href="#&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;" class="headerlink" title="&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;"></a>&#x5173;&#x4E8E;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x56DE;&#x6536;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC算法"><span class="toc-text"><a href="#GC&#x7B97;&#x6CD5;" class="headerlink" title="GC&#x7B97;&#x6CD5;"></a>GC&#x7B97;&#x6CD5;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数算法（Reference-Counting-Collector）"><span class="toc-text"><a href="#&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference-Counting-Collector&#xFF09;" class="headerlink" title="&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference Counting Collector&#xFF09;"></a>&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;&#xFF08;Reference Counting Collector&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根搜索算法（Tracing-Collector）"><span class="toc-text"><a href="#&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing-Collector&#xFF09;" class="headerlink" title="&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing Collector&#xFF09;"></a>&#x6839;&#x641C;&#x7D22;&#x7B97;&#x6CD5;&#xFF08;Tracing Collector&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-清除法"><span class="toc-text"><a href="#&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;" class="headerlink" title="&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;"></a>&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x6CD5;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记—整理算法（标记-压缩）"><span class="toc-text"><a href="#&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;" class="headerlink" title="&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;"></a>&#x6807;&#x8BB0;&#x2014;&#x6574;&#x7406;&#x7B97;&#x6CD5;&#xFF08;&#x6807;&#x8BB0;-&#x538B;&#x7F29;&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制算法"><span class="toc-text"><a href="#&#x590D;&#x5236;&#x7B97;&#x6CD5;" class="headerlink" title="&#x590D;&#x5236;&#x7B97;&#x6CD5;"></a>&#x590D;&#x5236;&#x7B97;&#x6CD5;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增量算法"><span class="toc-text"><a href="#&#x589E;&#x91CF;&#x7B97;&#x6CD5;" class="headerlink" title="&#x589E;&#x91CF;&#x7B97;&#x6CD5;"></a>&#x589E;&#x91CF;&#x7B97;&#x6CD5;</span></a></li></ol></li></ol>
    </div>

        <blockquote>
<p>关于垃圾回收机制，我们一般只关心下面两个问题。</p>
</blockquote>
<ul>
<li>什么时候回收</li>
<li>怎么回收</li>
</ul>
<blockquote>
<p>首先介绍一下Java中的四中引用</p>
</blockquote>
<p><strong>Java中的四种引用</strong></p>
<ol>
<li>强引用  不会被回收</li>
<li>弱引用  在内存不足时才会被回收</li>
<li>软引用  一旦触发了GC就会被回收</li>
<li>虚引用  没有用处的引用，被用来跟踪引用状态</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Car car=<span class="keyword">new</span> Car();</span><br><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> WeakReference(Car)(car);</span><br></pre></td></tr></table></figure>
<p>这是一个弱引用的例子<br><br>weakCar 为newCar()的弱引用<br><br>这样可以取出弱引用的对象<br>Car car=weakCar</p>
<h3 id="关于什么时候回收"><a href="#关于什么时候回收" class="headerlink" title="关于什么时候回收"></a>关于什么时候回收</h3><p>垃圾回收用户来说是透明的，即我们不需要关心什么时候回收，怎样回收，当然我们也可以强制回收。</p>
<ol>
<li>当内存不足时，Jvm会自动回收</li>
<li>我们可以用System.gc()通知jvm进行垃圾回收，但是不一定会马上执行。</li>
</ol>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：</p>
<ol>
<li>找到所有存活对象</li>
<li>回收被无用对象占用的内存空间，使该空间可被程序再次使用。</li>
</ol>
<p><strong>判断对象是否为垃圾</strong></p>
<h4 id="引用计数算法（Reference-Counting-Collector）"><a href="#引用计数算法（Reference-Counting-Collector）" class="headerlink" title="引用计数算法（Reference Counting Collector）"></a>引用计数算法（Reference Counting Collector）</h4><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为0。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<p>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）。</p>
<p>缺点： 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。</p>
<h4 id="根搜索算法（Tracing-Collector）"><a href="#根搜索算法（Tracing-Collector）" class="headerlink" title="根搜索算法（Tracing Collector）"></a>根搜索算法（Tracing Collector）</h4><p>首先了解一个概念：根集</p>
<p>根集里面都包括什么：</p>
<ol>
<li>Java栈中的引用</li>
<li>本地方法栈JNI（Native方法）引用</li>
<li>方法区中的静态变量的引用</li>
<li>方法区中的常量的引用</li>
</ol>
<p>这种算法的基本思路：</p>
<ol>
<li>通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。</li>
<li>找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。</li>
<li>重复第二步</li>
<li>搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</li>
<li></li>
</ol>
<p>然后再标记可达对象：</p>
<p>首先，垃圾回收器将某些特殊的对象定义为GC根对象。所谓的GC根对象包括：</p>
<ol>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li>
<li>本地方法栈中JNI（Native方法）的引用对象</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>活跃线程</li>
</ol>
<p>接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。</p>
<p><strong>关于标记阶段有几个关键点是值得注意的：</strong></p>
<ol>
<li>开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。</li>
<li>暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。</li>
<li>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：<br>（1）如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法，当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。<br>（2）如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li>
</ol>
<p><strong>回收垃圾的算法</strong></p>
<h4 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h4><p> 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<br> 同时，Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。</p>
<p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。<br>缺点：会产生大量的内存碎片，如果现在有一个对象需要的内存大于所有的碎片，就会不停的出发gc，最后抛出oom。</p>
<h4 id="标记—整理算法（标记-压缩）"><a href="#标记—整理算法（标记-压缩）" class="headerlink" title="标记—整理算法（标记-压缩）"></a>标记—整理算法（标记-压缩）</h4><p>该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<p>优点：（1）经过整理之后，新对象的分配只需要通过指针碰撞便能完成（Pointer Bumping），相当简单。（2）使用这种方法空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p>
<p>缺点：GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p>
<p>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。一种典型的基于Coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。</p>
<p>优点：（1）标记阶段和复制阶段可以同时进行。（2）每次只对一块内存进行回收，运行高效。（3）只需移动栈顶指针，按顺序分配内存即可，实现简单。（4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）</p>
<p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p>
<h4 id="增量算法"><a href="#增量算法" class="headerlink" title="增量算法"></a>增量算法</h4><p>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>优点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。</p>
<p>缺点：因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-19T13:57:51.000Z"><a href="/2018/04/19/scaleType/">2018-04-19</a></time>
        
  
    <h1 class="title"><a href="/2018/04/19/scaleType/">scaleType</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#background"><span class="toc-text"><a href="#background" class="headerlink" title="background"></a>background</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src"><span class="toc-text"><a href="#src" class="headerlink" title="src"></a>src</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#详细的scaleType"><span class="toc-text"><a href="#&#x8BE6;&#x7EC6;&#x7684;scaleType" class="headerlink" title="&#x8BE6;&#x7EC6;&#x7684;scaleType"></a>&#x8BE6;&#x7EC6;&#x7684;scaleType</span></a></li></ol></li></ol>
    </div>

        <blockquote>
<p>之前不懂给ImageView设置background和src有什么区别。<br><br>两者的主要区别就在于src支持各种缩放方式，而通过background指定没有。<br>从定义来讲，src表示前景，指图片的内容，background指的是背景。</p>
</blockquote>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>通过background主要给view设置背景颜色或者是drawable，设置颜色的时候会填充整个view，设置drawable时要根据具体的drawable来定，当给ImageView设置background为图片时，主要有以下两种情况。</p>
<ol>
<li>当ImageView设置为wrap_content时</li>
</ol>
<p>ImageView的图片不会被拉伸，图片有多大，ImageView就有多大</p>
<ol>
<li>当ImageView设置为match_parent时</li>
</ol>
<p>ImageView的图片会在xy方向同时拉伸填充满整个ImageView</p>
<h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><p>src特有的属性scaleType</p>
<h4 id="详细的scaleType"><a href="#详细的scaleType" class="headerlink" title="详细的scaleType"></a>详细的scaleType</h4><ol>
<li>android:scaleType=”center” </li>
</ol>
<p>保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。</p>
<ol>
<li>android:scaleType=”centerCrop</li>
</ol>
<p>以填满整个ImageView为目的，将原图的中心对准ImageView的中心，等比例放大原图，直到填满ImageView为止（指的是ImageView的宽和高都要填满），原图超过ImageView的部分作裁剪处理。<br>即最短边与View相等，长边截掉。</p>
<ol>
<li>android:scaleType=”centerInside</li>
</ol>
<p>以原图完全显示为目的，将图片的内容完整居中显示，通过按比例缩小原图的size宽(高)等于或小于ImageView的宽(高)。如果原图的size本身就小于ImageView的size，则原图的size不作任何处理，居中显示在ImageView。即最长边与View相等</p>
<ol>
<li>android:scaleType=”matrix</li>
</ol>
<p>不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理。</p>
<ol>
<li>android:scaleType=fitCenter</li>
</ol>
<p>当视图View的大小比图片小时和centerInside相同，当视图View比图片大时，centerInside图片不会变化，而fitcenter会按比例填充屏幕</p>
<ol>
<li>android:scaleType=”fitEnd</li>
</ol>
<p>把原图按比例扩大或缩小到ImageView的ImageView的（最小高度），居尾显示。</p>
<ol>
<li>android:scaleType=”fitStart</li>
</ol>
<p>把原图按比例扩大(缩小)到ImageView的高度，显示在ImageView的上部分位置</p>
<ol>
<li>android:scaleType=”fitXY”</li>
</ol>
<p>把原图按照指定的大小在View中显示，拉伸显示图片，不保持原比例，填满ImageView.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-18T05:33:07.000Z"><a href="/2018/04/18/classLoader/">2018-04-18</a></time>
        
  
    <h1 class="title"><a href="/2018/04/18/classLoader/">classLoader</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区包括哪几个部分"><span class="toc-text"><a href="#&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x533A;&#x5305;&#x62EC;&#x54EA;&#x51E0;&#x4E2A;&#x90E8;&#x5206;" class="headerlink" title="&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x533A;&#x5305;&#x62EC;&#x54EA;&#x51E0;&#x4E2A;&#x90E8;&#x5206;"></a>&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x533A;&#x5305;&#x62EC;&#x54EA;&#x51E0;&#x4E2A;&#x90E8;&#x5206;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#这五个部分都存储了哪些数据"><span class="toc-text"><a href="#&#x8FD9;&#x4E94;&#x4E2A;&#x90E8;&#x5206;&#x90FD;&#x5B58;&#x50A8;&#x4E86;&#x54EA;&#x4E9B;&#x6570;&#x636E;" class="headerlink" title="&#x8FD9;&#x4E94;&#x4E2A;&#x90E8;&#x5206;&#x90FD;&#x5B58;&#x50A8;&#x4E86;&#x54EA;&#x4E9B;&#x6570;&#x636E;"></a>&#x8FD9;&#x4E94;&#x4E2A;&#x90E8;&#x5206;&#x90FD;&#x5B58;&#x50A8;&#x4E86;&#x54EA;&#x4E9B;&#x6570;&#x636E;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-程序计数器"><span class="toc-text"><a href="#1-&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;" class="headerlink" title="1.&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;"></a>1.&#x7A0B;&#x5E8F;&#x8BA1;&#x6570;&#x5668;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java栈"><span class="toc-text"><a href="#2-Java&#x6808;" class="headerlink" title="2.Java&#x6808;"></a>2.Java&#x6808;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-本地方法栈"><span class="toc-text"><a href="#3-&#x672C;&#x5730;&#x65B9;&#x6CD5;&#x6808;" class="headerlink" title="3.&#x672C;&#x5730;&#x65B9;&#x6CD5;&#x6808;"></a>3.&#x672C;&#x5730;&#x65B9;&#x6CD5;&#x6808;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-堆"><span class="toc-text"><a href="#4-&#x5806;" class="headerlink" title="4.&#x5806;"></a>4.&#x5806;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-方法区"><span class="toc-text"><a href="#5-&#x65B9;&#x6CD5;&#x533A;" class="headerlink" title="5.&#x65B9;&#x6CD5;&#x533A;"></a>5.&#x65B9;&#x6CD5;&#x533A;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java类加载流程"><span class="toc-text"><a href="#Java&#x7C7B;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;" class="headerlink" title="Java&#x7C7B;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;"></a>Java&#x7C7B;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-类的加载"><span class="toc-text"><a href="#&#x4E00;-&#x7C7B;&#x7684;&#x52A0;&#x8F7D;" class="headerlink" title="&#x4E00; &#x7C7B;&#x7684;&#x52A0;&#x8F7D;"></a>&#x4E00; &#x7C7B;&#x7684;&#x52A0;&#x8F7D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二-类的连接"><span class="toc-text"><a href="#&#x4E8C;-&#x7C7B;&#x7684;&#x8FDE;&#x63A5;" class="headerlink" title="&#x4E8C; &#x7C7B;&#x7684;&#x8FDE;&#x63A5;"></a>&#x4E8C; &#x7C7B;&#x7684;&#x8FDE;&#x63A5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三-类的初始化"><span class="toc-text"><a href="#&#x4E09;-&#x7C7B;&#x7684;&#x521D;&#x59CB;&#x5316;" class="headerlink" title="&#x4E09; &#x7C7B;&#x7684;&#x521D;&#x59CB;&#x5316;"></a>&#x4E09; &#x7C7B;&#x7684;&#x521D;&#x59CB;&#x5316;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的卸载"><span class="toc-text"><a href="#&#x7C7B;&#x7684;&#x5378;&#x8F7D;" class="headerlink" title="&#x7C7B;&#x7684;&#x5378;&#x8F7D;"></a>&#x7C7B;&#x7684;&#x5378;&#x8F7D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器"><span class="toc-text"><a href="#&#x7C7B;&#x52A0;&#x8F7D;&#x5668;" class="headerlink" title="&#x7C7B;&#x52A0;&#x8F7D;&#x5668;"></a>&#x7C7B;&#x52A0;&#x8F7D;&#x5668;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载顺序？"><span class="toc-text"><a href="#&#x52A0;&#x8F7D;&#x987A;&#x5E8F;&#xFF1F;" class="headerlink" title="&#x52A0;&#x8F7D;&#x987A;&#x5E8F;&#xFF1F;"></a>&#x52A0;&#x8F7D;&#x987A;&#x5E8F;&#xFF1F;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bootstrap-CLasslode"><span class="toc-text"><a href="#Bootstrap-CLasslode" class="headerlink" title="Bootstrap CLasslode"></a>Bootstrap CLasslode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extention-ClassLoader"><span class="toc-text"><a href="#Extention-ClassLoader" class="headerlink" title="Extention ClassLoader"></a>Extention ClassLoader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AppClassLoader"><span class="toc-text"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委托模式"><span class="toc-text"><a href="#&#x53CC;&#x4EB2;&#x59D4;&#x6258;&#x6A21;&#x5F0F;" class="headerlink" title="&#x53CC;&#x4EB2;&#x59D4;&#x6258;&#x6A21;&#x5F0F;"></a>&#x53CC;&#x4EB2;&#x59D4;&#x6258;&#x6A21;&#x5F0F;</span></a></li></ol></li></ol>
    </div>

        <p>ClassLoader翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。理解ClassLoader的加载机制，也有利于我们编写出更高效的代码。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习ClassLoader这种加载机制。</p>
<blockquote>
<p>在了解类加载机制前，我们先了解一下JVM内存分配，运行时内存区域</p>
</blockquote>
<h2 id="运行时数据区包括哪几个部分"><a href="#运行时数据区包括哪几个部分" class="headerlink" title="运行时数据区包括哪几个部分"></a>运行时数据区包括哪几个部分</h2><ul>
<li>程序计数器</li>
<li>Java栈 （存储引用变量）</li>
<li>本地方法栈</li>
<li>方法区（存储常量，静态变量）</li>
<li>堆（存储对象）</li>
</ul>
<p><img src="/2018/04/18/classLoader/JVMMemory.png" alt=""></p>
<h3 id="这五个部分都存储了哪些数据"><a href="#这五个部分都存储了哪些数据" class="headerlink" title="这五个部分都存储了哪些数据"></a>这五个部分都存储了哪些数据</h3><h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h4><p>程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，<strong>它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址）</strong>，当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。</p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。</p>
<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。</p>
<p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
<h4 id="2-Java栈"><a href="#2-Java栈" class="headerlink" title="2.Java栈"></a>2.Java栈</h4><p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，<strong>在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。</strong>当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。</p>
<p>局部变量表，顾名思义，想必不用解释大家应该明白它的作用了吧。就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。</p>
<p>操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。</p>
<p>指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。</p>
<p>方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p>
<p>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。</p>
<h4 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h4><p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</p>
<h4 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h4><p>在C语言中，堆这部分空间是唯一一个程序员可以管理的内存区域。程序员可以通过malloc函数和free函数在堆上申请和释放空间。那么在Java中是怎么样的呢？</p>
<p><strong>Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。</strong>只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。</p>
<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h4><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，<strong>存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等</strong>。</p>
<p>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
<hr>
<p>了解了JVM内存区域后再来看一下类的加载流程</p>
<h2 id="Java类加载流程"><a href="#Java类加载流程" class="headerlink" title="Java类加载流程"></a>Java类加载流程</h2><blockquote>
<p>在了解类加载器之前，我们先了解一下类的加载机制<br>首先，在代码编译后，就会生成JVM（Java虚拟机）能够识别的二进制字节流文件（*.class）。而JVM把Class文件中的类描述数据从文件加载到内存，并对数据进行校验、转换解析、初始化，使这些数据最终成为可以被JVM直接使用的Java类型，这个说来简单但实际复杂的过程叫做JVM的类加载机制。</p>
</blockquote>
<p><strong>虚拟机类加载机制：</strong>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p><strong>类的生命周期：</strong></p>
<ol>
<li>加载 loading</li>
<li>验证 verification</li>
<li>准备 preparation</li>
<li>解析 resolution</li>
<li>初始化 initialization</li>
<li>使用 using</li>
<li>卸载 unloading</li>
</ol>
<p>Class文件中的“类”从加载到JVM内存中，到卸载出内存过程有七个生命周期阶段。类加载机制包括了前五个阶段。<br>如下图所示：<br><img src="/classLoader/classLifeCircle.png" alt=""><br>　　<br>其中，加载、验证、准备、初始化、卸载的开始顺序是确定的，注意，只是按顺序开始，进行与结束的顺序并不一定。解析阶段可能在初始化之后开始。<br>Java语言里，类型的加载和连接过程是在程序运行期间完成的。</p>
<p>Class文件中的“类”从加载到JVM内存中，到卸载出内存过程有七个生命周期阶段。类加载机制包括了前五个阶段。</p>
<h3 id="一-类的加载"><a href="#一-类的加载" class="headerlink" title="一 类的加载"></a>一 类的加载</h3><p>我们平常说的加载大多不是指的类加载机制，只是类加载机制中的第一步加载。在这个阶段，JVM主要完成三件事：</p>
<ol>
<li>通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。</li>
</ol>
<h3 id="二-类的连接"><a href="#二-类的连接" class="headerlink" title="二 类的连接"></a>二 类的连接</h3><p>类的加载过程后生成了类的java.lang.Class对象，接着会进入连接阶段，连接阶段负责将类的二进制数据合并入JRE（Java运行时环境）中。类的连接大致分三个阶段。</p>
<ol>
<li><strong>验证：</strong> 验证被加载后的类是否有正确的结构，类数据是否会符合虚拟机的要求，确保不会危害虚拟机安全。</li>
<li><strong>准备：</strong>为类的静态变量（static filed）在方法区分配内存，并赋默认初值（0值或null值）。如static int a = 100;静态变量a就会在准备阶段被赋默认值0。</li>
</ol>
<p>另外，静态常量（static final filed）会在准备阶段赋程序设定的初值，如static final int a = 666;  静态常量a就会在准备阶段被直接赋值为666，对于静态变量，这个操作是在初始化阶段进行的。</p>
<ol>
<li><strong>解析：</strong>将常量池内的符号引用变为直接引用。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</li>
</ol>
<h3 id="三-类的初始化"><a href="#三-类的初始化" class="headerlink" title="三 类的初始化"></a>三 类的初始化</h3><p>类初始化是类加载的最后一步，除了加载阶段，用户可以通过自定义的类加载器参与，其他阶段都完全由虚拟机主导和控制。到了初始化阶段才真正执行Java代码。</p>
<p><strong>类的初始化的主要工作是为静态变量赋程序设定的初值。</strong><br>如static int a = 100;在准备阶段，a被赋默认值0，在初始化阶段就会被赋值为100。<br>执行静态代码块，构造器。</p>
<p>各成员的执行顺序：</p>
<ol>
<li>父类静态成员和静态代码块，按代码中的顺序</li>
<li>子类静态成员和静态代码块，按代码中的顺序</li>
<li>父类实例成员和实例初始化块，按代码顺序</li>
<li>父类的构造方法</li>
<li>子类的实例成员和实例初始化块，按代码顺序</li>
<li>子类的构造方法</li>
</ol>
<p><strong>所有静态成员和静态代码块只会执行一次</strong></p>
<p><strong>Java虚拟机规范中严格规定了有且只有五种情况必须对类进行初始化：</strong></p>
<ul>
<li>使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。</li>
<li>通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。</li>
<li>当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。</li>
<li>当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。</li>
<li>使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</li>
</ul>
<p><strong>注意，虚拟机规范使用了“有且只有”这个词描述，这五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”。</strong></p>
<p><strong>被动引用的例子</strong></p>
<ol>
<li>通过子类引用父类的静态字段，对于父类属于“主动引用”的第一种情况，对于子类，没有符合“主动引用”的情况，故子类不会进行初始化。</li>
<li>通过数组来引用类，不会触发类的初始化，因为是数组new，而类没有被new，所以没有触发任何“主动引用”条款，属于“被动引用”。</li>
<li>静态常量在编译阶段就会被存入调用类的常量池中，不会引用到定义常量的类，这是一个特例，需要特别记忆，不会触发类的初始化！</li>
</ol>
<p>举个例子加深一下印象：写出下面代码的正确结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        count1++;  </span><br><span class="line">        count2++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleTon;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();  </span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);  </span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案 count1=1;count2=0<br>解析：</p>
<ol>
<li>类加载的时候给静态成员赋初值singleTon=null;count1=0;count2=0;</li>
<li>在main函数中调用了SingleTon的静态方法，所以执行类的初始化。</li>
<li>new SingleTon()，调用了构造方法，所以count1=1;count2=1</li>
<li>往下执行，为count1和count2赋值，count1没有赋值还为1，count2赋值为0；</li>
<li>所以最后结果count1=1;count2=0。</li>
</ol>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p>
<ul>
<li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。</li>
<li>加载该类的ClassLoader已经被GC。</li>
<li>该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java自带三个类加载器：</p>
<ul>
<li><strong>Bootstrap ClassLoader</strong> 最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。</li>
<li><strong>Extention ClassLoader </strong> 扩展的类加载器，加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。 </li>
<li><strong>Appclass Loader也称为SystemAppClass</strong>加载当前应用的classpath的所有类。</li>
</ul>
<h3 id="加载顺序？"><a href="#加载顺序？" class="headerlink" title="加载顺序？"></a>加载顺序？</h3><ol>
<li>Bootstrap CLasslode</li>
<li>Extention ClassLoader</li>
<li>AppClassLoader</li>
</ol>
<p><img src="/classLoader/classloader.png" alt=""></p>
<p>一般情况下自底向上检查类是否被加载，自顶向下尝试加载类。</p>
<h4 id="Bootstrap-CLasslode"><a href="#Bootstrap-CLasslode" class="headerlink" title="Bootstrap CLasslode"></a>Bootstrap CLasslode</h4><p>为了更好的理解，我们可以查看源码。<br>看sun.misc.Launcher,它是一个java虚拟机的入口应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create extension class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The class loader used for loading installed extensions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class loader used for loading from java.class.path.</span></span><br><span class="line"><span class="comment">     * runs in a restricted security context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>源码有精简，我们可以得到相关的信息。 </p>
<ol>
<li>Launcher初始化了ExtClassLoader和AppClassLoader。 </li>
<li>Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty(“sun.boot.class.path”)得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。</li>
</ol>
<p>我们可以先代码测试一下sun.boot.class.path是什么内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br></pre></td></tr></table></figure>
<p>得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\resources.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\rt.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\sunrsasign.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jsse.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jce.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\charsets.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\jfr.jar;</span><br><span class="line">C:\Program Files\Java\jre1.8.0_91\classes</span><br></pre></td></tr></table></figure></p>
<h4 id="Extention-ClassLoader"><a href="#Extention-ClassLoader" class="headerlink" title="Extention ClassLoader"></a>Extention ClassLoader</h4><p>我们先前的内容有说过，可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jre1.8.0_91\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>
<h4 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h4><p>可以看到AppClassLoader加载的就是java.class.path下的路径。我们同样打印它的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">D:\workspace\ClassLoaderDemo\bin</span><br></pre></td></tr></table></figure>
<p>这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。</p>
<h3 id="双亲委托模式"><a href="#双亲委托模式" class="headerlink" title="双亲委托模式"></a>双亲委托模式</h3><p>从1.2版本开始，Java引入了双亲委托模型，从而更好的保证Java平台的安全。在此模型下，当一个装载器被请求装载某个类时，它首先委托自己的parent去装载，若parent能装载，则返回这个类所对应的Class对象，若parent不能装载，则由parent的请求者(即自己)去装载。</p>
<p><img src="/classLoader/parent.png" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-08T08:48:54.000Z"><a href="/2018/04/08/HandlerUpdateUI/">2018-04-08</a></time>
        
  
    <h1 class="title"><a href="/2018/04/08/HandlerUpdateUI/">HandlerUpdateUI</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <blockquote>
<p>利用Handler,Message在主线程和子线程中通信更新UI,Handler.post,Handler.postDelay</p>
</blockquote>
<p>第一种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//主线程中new一个handler接收消息，更新UI</span></span><br><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    mTestTV.setText(<span class="string">"This is handleMessage"</span>);<span class="comment">//更新UI</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//子线程中发送消息</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">//在子线程有一段耗时操作,比如请求网络</span></span><br><span class="line">                    mHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure>
<p>第二种方式：handler.post(new Runnable{…});</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler mHandler;<span class="comment">//全局变量</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">//在子线程有一段耗时操作,比如请求网络</span></span><br><span class="line">                        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                mTestTV.setText(<span class="string">"This is post"</span>);<span class="comment">//更新UI</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看post的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);<span class="comment">//getPostMessage方法是两种发送消息的不同之处</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实post方法post过去的是一段代码，相当于将这个Runable体放入消息队列中，那么looper拿取这段代码去交给handler来处理。以后有时间再来分析一下这段源码。</p>
<p>第三种方式，其时和第二种一样，postDelayed：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testTv.postDelay(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;,<span class="number">2</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>可以在自定的时间之后发送消息。</p>
<p>另外在这写一个和这个相关的定时器：</p>
<hr>
<p>在handleMessage方法内部调用sendMessage方法，可以实现数据的动态获取和更新<br><br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>) Handler handler=<span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                mTextView.setText(mSlipDemo.getScrollX()+<span class="string">""</span>);</span><br><span class="line">                sendEmptyMessage(<span class="number">123</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  handler.sendEmptyMessage(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样MTextView就可以实时捕捉数据了<br>不过得在外部先发送一个消息。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-07T10:40:42.000Z"><a href="/2018/04/07/TouchEventDispatch/">2018-04-07</a></time>
        
  
    <h1 class="title"><a href="/2018/04/07/TouchEventDispatch/">TouchEventDispatch</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#View触摸事件的分发"><span class="toc-text"><a href="#View&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;" class="headerlink" title="View&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;"></a>View&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View的位置信息"><span class="toc-text"><a href="#View&#x7684;&#x4F4D;&#x7F6E;&#x4FE1;&#x606F;" class="headerlink" title="View&#x7684;&#x4F4D;&#x7F6E;&#x4FE1;&#x606F;"></a>View&#x7684;&#x4F4D;&#x7F6E;&#x4FE1;&#x606F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点击事件的分发过程由三个非常重要的方法完成："><span class="toc-text"><a href="#&#x70B9;&#x51FB;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;&#x8FC7;&#x7A0B;&#x7531;&#x4E09;&#x4E2A;&#x975E;&#x5E38;&#x91CD;&#x8981;&#x7684;&#x65B9;&#x6CD5;&#x5B8C;&#x6210;&#xFF1A;" class="headerlink" title="&#x70B9;&#x51FB;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;&#x8FC7;&#x7A0B;&#x7531;&#x4E09;&#x4E2A;&#x975E;&#x5E38;&#x91CD;&#x8981;&#x7684;&#x65B9;&#x6CD5;&#x5B8C;&#x6210;&#xFF1A;"></a>&#x70B9;&#x51FB;&#x4E8B;&#x4EF6;&#x7684;&#x5206;&#x53D1;&#x8FC7;&#x7A0B;&#x7531;&#x4E09;&#x4E2A;&#x975E;&#x5E38;&#x91CD;&#x8981;&#x7684;&#x65B9;&#x6CD5;&#x5B8C;&#x6210;&#xFF1A;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三个方法的分布情况"><span class="toc-text"><a href="#&#x4E09;&#x4E2A;&#x65B9;&#x6CD5;&#x7684;&#x5206;&#x5E03;&#x60C5;&#x51B5;" class="headerlink" title="&#x4E09;&#x4E2A;&#x65B9;&#x6CD5;&#x7684;&#x5206;&#x5E03;&#x60C5;&#x51B5;"></a>&#x4E09;&#x4E2A;&#x65B9;&#x6CD5;&#x7684;&#x5206;&#x5E03;&#x60C5;&#x51B5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析"><span class="toc-text"><a href="#&#x89E3;&#x6790;" class="headerlink" title="&#x89E3;&#x6790;"></a>&#x89E3;&#x6790;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public-boolean-dispatchTouchEvent-MotionEvent-ev"><span class="toc-text"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent ev)"></a>public boolean dispatchTouchEvent(MotionEvent ev)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onInterceptTouchEvent-MotionEvent-e"><span class="toc-text"><a href="#onInterceptTouchEvent-MotionEvent-e" class="headerlink" title="onInterceptTouchEvent(MotionEvent e)"></a>onInterceptTouchEvent(MotionEvent e)</span></a></li></ol></li></ol></li></ol>
    </div>

        <h2 id="View触摸事件的分发"><a href="#View触摸事件的分发" class="headerlink" title="View触摸事件的分发"></a>View触摸事件的分发</h2><blockquote>
<p>Android手机最大的器官就是触摸屏了，所以掌握好触摸操作是非常重要的</p>
</blockquote>
<p>在分析触摸事件的分发之前，我们先看一下什么是触摸事件：</p>
<p>MotionEvent</p>
<p>在手指接触屏幕后所产生的一系列事件中，典型的有下面几种</p>
<ol>
<li>ACTION_DOWN –手指刚接触屏幕</li>
<li>ACTION_MOVE–手指在屏幕上滑动</li>
<li>ACTION_UO–手指从屏幕上松开的一瞬间</li>
</ol>
<hr>
<h2 id="View的位置信息"><a href="#View的位置信息" class="headerlink" title="View的位置信息"></a>View的位置信息</h2><p>获取点击位置的坐标：MotionEvent的方法<br>得到相对于父view的坐标</p>
<ol>
<li>getX()</li>
<li>getY()</li>
</ol>
<p>得到相对于屏幕的坐标：</p>
<ol>
<li>getRawX()</li>
<li>getRawY()</li>
</ol>
<p>获取控件的坐标：</p>
<ul>
<li>getLeft() 获取左上角的横坐标</li>
<li>getTop()获取左上角纵坐标</li>
<li>getRight()获取右下角横坐标</li>
<li>getBttom()获取右下角纵坐标</li>
</ul>
<p><strong>每个View都是矩形</strong></p>
<h2 id="点击事件的分发过程由三个非常重要的方法完成："><a href="#点击事件的分发过程由三个非常重要的方法完成：" class="headerlink" title="点击事件的分发过程由三个非常重要的方法完成："></a>点击事件的分发过程由三个非常重要的方法完成：</h2><ol>
<li>public boolean dispatchTouchEvent(MotionEvent ev)</li>
<li>public boolean onInterceptTouchEvent(MotionEvent ev)  </li>
<li>public boolean onTouchEvent(MotionEvent event) </li>
</ol>
<h3 id="三个方法的分布情况"><a href="#三个方法的分布情况" class="headerlink" title="三个方法的分布情况"></a>三个方法的分布情况</h3><p>在View中包含以下两个方法：</p>
<blockquote>
<p>public boolean dispatchTouchEvent(MotionEvent ev)； <br><br>public boolean onTouchEvent(MotionEvent ev);</p>
</blockquote>
<p>在ViewGroup中包含以下三个方法：</p>
<blockquote>
<p>public boolean dispatchTouchEvent(MotionEvent ev)； <br><br>public boolean onInterceptTouchEvent(MotionEvent ev); <br><br>public boolean onTouchEvent(MotionEvent ev);</p>
</blockquote>
<p>在Activity中包含以下两个方法：</p>
<blockquote>
<p>public boolean dispatchTouchEvent(MotionEvent ev)； <br><br>public boolean onTouchEvent(MotionEvent ev);</p>
</blockquote>
<p>关于这三个方法的关系，可以用这样一段伪码来概括：</p>
<p>其实严格来讲，只有ViewGroup满足这个伪码，因为对于Activity来说没有interceptTouchEvent方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    bool result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(e)) &#123;</span><br><span class="line">        result = onTouchEvent(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>事件分发顺序Activity-&gt;Window-&gt;View(ViewGroup和View)</li>
<li>一个事件序列包括一个down,若干个move，一个up</li>
<li>一个事件序列只能被一个view拦截消耗</li>
<li>当触摸事件发生后，其实就是调用了ACtivity的dispatchTouchEvent(MotionEvent e)方法，然后在这个方法中又调用了Window的这个方法，然后一层一层传递下去</li>
<li>当一个view决定处理Down动作，这个事件的后来的所有动作都会交给这个view处理。</li>
<li>一个触摸事件会从</li>
</ul>
<h4 id="public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent ev)"></a>public boolean dispatchTouchEvent(MotionEvent ev)</h4><p>表示触摸事件的分发，返回值表示是否消耗该触摸事件。</p>
<p>首先看一下Activity的这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">           onUserInteraction();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先是Activity调用这个方法，然后交给所附属的Window进行分发,如果返回true则表示已经被处理，整个事件已经结束了，所有的view都返回false，onTouchEvent会被调用。</p>
<p>这个Window是个抽象类，真正的实现者是Phone Window，然后PhoneWindow将事件传递给DecorView，这个DecroView就是Activity的setContentView设置的View的父View，然后事件会被传到这个View，我们称之为顶级View</p>
<p><strong>顶级View对事件的分发</strong></p>
<p>顶级View一般是一个ViewGroup</p>
<p>所以这个分发过程严格满足下面的伪码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    bool result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(e)) &#123;</span><br><span class="line">        result = onTouchEvent(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就要讲到第二个方法了。</p>
<h4 id="onInterceptTouchEvent-MotionEvent-e"><a href="#onInterceptTouchEvent-MotionEvent-e" class="headerlink" title="onInterceptTouchEvent(MotionEvent e)"></a>onInterceptTouchEvent(MotionEvent e)</h4><p>判断是否拦截某个事件，如果当前的ViewGroup拦截了某个事件，那么当前事件的其他序列就不会再调用这个方法。</p>
<p>默认不拦截</p>
<p>从上面的伪码看出，ViewGroup在调用dispatchTouchEvent的时候，会先调用onInterceptTouchEvent，</p>
<p>具体调用的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   intercepted = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">               <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">               intercepted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup在下面两种情况下会调用自己的onInterceptTouchEvent</p>
<ol>
<li>事件类型为ACTION_DOWN</li>
<li>mFirstTouchTarget!=null;</li>
</ol>
<p>ACTION_DOWN我们都知道是什么，那么这个mFirstTouchTarget到底是什么呢</p>
<p>从后面的代码可以看出，当该事件没有被自己处理时mFirstTouchTarget!=null，一旦当前ViewGroup对事件拦截，这个条件就不成立。所以一旦拦截了ACTION_DOWN,这个方法将不会再被调用。</p>
<p>当事件ACTION_DOWN到来时，ViewGroup会调用自己的onInterceptTouchEvent，来询问自己是否要拦截</p>
<p>onInterceptTouchEvent的源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一般来说这个方法总会返回false，只有这个ViewGroup为可滑动或者是可点击的时候，才会返回true。</p>
<p>可以看出这个方法是否调用，还受一个参数的影响：FLAG_DISALLOW_INTERCEPT</p>
<p>一般这个参数由子View通过parent.requestDisallowInterceptTouchEvent(boolean b)来设置</p>
<p>如果传入的是true，就不允许parent拦截除ACTION_DOWN以外的事件，因为当ViewGroup一旦拦截了ACTION_DOWN之后，这个标志位就会被重置。</p>
<p><strong>在这整理一下思路</strong></p>
<p>当ACTION_DOWN事件到来的时候，VIewGroup首先调用自己的dispatchTouchEvent，然后因为是ACTION_DOWN所以会调用自己的onInterceptTouchEvent来询问自己是否要拦截该事件，如果不拦截的话，就将此事件分发给子View，即子View的dispatchTouchEvent方法调用，就此轮回。但是如果此时子View也没有拦截ACTION——DOWN，而且自己想要拦截ACTION_MOVE(一般的滑动冲突都是这个造成的），因为子View没有拦截，所以mFirstTouchTarget != null这个条件就成立，所以本身的onInterceptTouchEvent就会被调用，就会拦截此事件。</p>
<p>关于解决滑动冲突的内部拦截法，今天，通过这么深刻的解读，我终于明白了。</p>
<p>外部拦截法，在parent的onInterceptTouchEvent中处理，内部拦截法，在子view的dispatchTouchEvent中处理</p>
<p>内部拦截法要求parent不能拦截ACTION_DOWN事件。</p>
<p>当ACTION_DOWN事件到来的时候，ViewGroup和其子View是都不会拦截该事件，子View在处理ACTION_DOWN事件的时候，就可以设置标志位，即parent.requestDisallowInterceptTouchEvent(true),不允许parent拦截事件，当ACTION_MOVE事件到来的时候，mFirstTouchTarget != null这个条件是满足的，但是标志位是不允许拦截，所以parent不会调用自己的onInterceptTouchEvent，也就是不会拦截，所以继续传给自己的子View，子View在,子view在对ACYTION_MOVE处理的时候就该判断了，这时是该自己处理呢，还是该parent处理呢，如果该父亲处理，就parent.requestDisallowInterceptTouchEvent(false)，这时候parent就自己处理了</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-07T10:39:56.000Z"><a href="/2018/04/07/HandlerThread/">2018-04-07</a></time>
        
  
    <h1 class="title"><a href="/2018/04/07/HandlerThread/">HandlerThread</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler类和Handler-Loop-MessageQueue的工作原理"><span class="toc-text"><a href="#Handler&#x7C7B;&#x548C;Handler-Loop-MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;" class="headerlink" title="Handler&#x7C7B;&#x548C;Handler,Loop,MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;"></a>Handler&#x7C7B;&#x548C;Handler,Loop,MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler，Looper，MessageQueue的工作原理："><span class="toc-text"><a href="#Handler&#xFF0C;Looper&#xFF0C;MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#xFF1A;" class="headerlink" title="Handler&#xFF0C;Looper&#xFF0C;MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#xFF1A;"></a>Handler&#xFF0C;Looper&#xFF0C;MessageQueue&#x7684;&#x5DE5;&#x4F5C;&#x539F;&#x7406;&#xFF1A;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerThread"><span class="toc-text"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法"><span class="toc-text"><a href="#&#x7528;&#x6CD5;" class="headerlink" title="&#x7528;&#x6CD5;"></a>&#x7528;&#x6CD5;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析："><span class="toc-text"><a href="#&#x89E3;&#x6790;&#xFF1A;" class="headerlink" title="&#x89E3;&#x6790;&#xFF1A;"></a>&#x89E3;&#x6790;&#xFF1A;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text"><a href="#&#x539F;&#x7406;" class="headerlink" title="&#x539F;&#x7406;"></a>&#x539F;&#x7406;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text"><a href="#&#x603B;&#x7ED3;" class="headerlink" title="&#x603B;&#x7ED3;"></a>&#x603B;&#x7ED3;</span></a></li></ol>
    </div>

        <h2 id="Handler类和Handler-Loop-MessageQueue的工作原理"><a href="#Handler类和Handler-Loop-MessageQueue的工作原理" class="headerlink" title="Handler类和Handler,Loop,MessageQueue的工作原理"></a>Handler类和Handler,Loop,MessageQueue的工作原理</h2><p>Handler类的作用主要有两种：</p>
<ol>
<li>在新启动的线程中发送消息。</li>
<li>在主线程中处理消息</li>
</ol>
<p>注：主线程已经封装有Loop的消息队列处理机制，无需再创建。</p>
<p>Handler类包含如下方法用于消息发送，处理：</p>
<ol>
<li>void handleMessage(Message msg):处理消息的方法</li>
<li>final boolean hasMessages(int what)：检查消息队列是否包含what的值。</li>
<li>final boolean hasMessages(int what, Object object)：检查消息队列是否包含what的值且object为指定对象。</li>
<li>Message obtainMessage()：获取消息。</li>
<li>sendEmptyMessage(int what)：发送空消息。</li>
<li>final boolean sendemptyMessageDelayed(int what, long delayMillis)：指定多少毫秒之后发送空消息。</li>
<li>final boolean sendMessage(Message msg)：立即发送消息。</li>
<li>final boolean sendMessageDelayed(Message msg, long delayMillis)：指定多少毫秒之后发送空消息。</li>
</ol>
<p>Demo:自动播放动画<br>下面代码实现是创建一个新线程来隔一定时间之后周期性的修改ImageView所显示的图片，实现一个动画效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//定义周期性显示的图片ID  </span></span><br><span class="line">        <span class="keyword">int</span>[] imageIds = <span class="keyword">new</span> <span class="keyword">int</span>[]  </span><br><span class="line">        &#123;  </span><br><span class="line">                R.drawable.1,  </span><br><span class="line">                R.drawable.2,  </span><br><span class="line">                R.drawable.3,  </span><br><span class="line">                R.drawable.4,  </span><br><span class="line">                R.drawable.5  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">int</span> currentImageId = <span class="number">0</span>;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">            setContentView(R.layout.main_activity);  </span><br><span class="line">            <span class="keyword">final</span> ImageView show = (ImageView) findViewById(R.id.main_bt);  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">final</span> Handler myhHandler = <span class="keyword">new</span> Handler()  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span>  </span></span><br><span class="line"><span class="function">                </span>&#123;  </span><br><span class="line">                    <span class="comment">//如果该消息是本程序所发送的  </span></span><br><span class="line">                    <span class="keyword">if</span> (msg.what == <span class="number">0x12345</span>) &#123;  </span><br><span class="line">                        <span class="comment">//动态的修改所显示的图片  </span></span><br><span class="line">                        show.setImageResource(imageIds[currentImageId++]%imageIds.length);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;;  </span><br><span class="line">            <span class="comment">//定义一个计时器，让该计时器周期性的执行指定任务  </span></span><br><span class="line">            <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123; <span class="comment">//TimerTask对象的本质是启动一个新线程  </span></span><br><span class="line">                  </span><br><span class="line">                <span class="meta">@Override</span>  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">                    <span class="comment">//发送空消息  </span></span><br><span class="line">                    myhHandler.sendEmptyMessage(<span class="number">0x12345</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, <span class="number">0</span>, <span class="number">1200</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：当Timertask新线程发送消息时，位于主线程的handleMessage(Message msg)方法自动被回调，动态的修改ImagView组件的属性。效果：由新线程来周期性的修改ImageView的属性，从而实现动画效果。</p>
<h3 id="Handler，Looper，MessageQueue的工作原理："><a href="#Handler，Looper，MessageQueue的工作原理：" class="headerlink" title="Handler，Looper，MessageQueue的工作原理："></a>Handler，Looper，MessageQueue的工作原理：</h3><p>Looper：每个线程只有一个Looper，它负责管理MessageQueue，会不断的从MessageQueue中取出消息，并将消息分发给Handler处理。</p>
<p>MessageQueue：由Looper负责管理。它采用先进先出的方式来管理Message。</p>
<p>Handler：它能把消息发送给Looper管理的MessageQueue，并负责处理Looper分给它的消息。</p>
<p>注：</p>
<ol>
<li>在主线程中，系统已经初始化了一个Looper对象，因此程序直接创建Handler即可，然后就可通过Handler来发送消息，处理消息。</li>
<li>在自己启动的子线程如果需要创建一个Handler实例去处理消息，必须自己创建一个Looper对象，并启动它（分别调用prepare()和loop()方法），下面讲解这两个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说明：prepare方法保证线程最多只有一个Looper对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (; ;) &#123;  </span><br><span class="line">            Message msg = queue.next();<span class="comment">//获取消息队列的下一个消息，如果没有消息，将会阻塞  </span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;<span class="comment">//如果消息为null,表明消息队列正在退出  </span></span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            Printer logging = me.mLogging;  </span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                logging.println(<span class="string">""</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            msg.target.dispatchMessage(msg);  </span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                logging.println(<span class="string">""</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//使用final修饰该标识符，保证在分发消息的过程中线程标识符不会被修改  </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();  </span><br><span class="line">            <span class="keyword">if</span> (iden != newIdent) &#123;  </span><br><span class="line">                logging.println(<span class="string">""</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            msg.recycle();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说明：loop()方法使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给该消息对应的Handler进行处理</p>
<p>在非主线程中使用Handler的步骤如下：</p>
<ol>
<li>调用Looper的prepare()方法为当前线程创建Looper对象（创建Looper对象时，它的构造器会自动创建与之配套的MessageQueue）。</li>
<li>有了Looper之后，创建Handler子类的实例，重写handleMessage()方法，该方法负责处理来自于其他线程的消息。</li>
<li>调用Looper的loop()方法启动Looper。</li>
</ol>
<p>Demo：使用新线程计算质数</p>
<p>该实例允许用户输入一个数值上限，当用户单击“计算”按钮时，该应用会将该上限数值发送到新启动的线程，让该线程来计算该范围内的所有质数（之所以不直接在UI线程中计算该范围的所有质数，是因为UI线程需要响应用户动作，如果在UI线程中执行一个耗时操作，将会导致UI线程被阻塞，引起ANR异常）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalPrime</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;  </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> String UPPER_NUM = <span class="string">"upper"</span>;  </span><br><span class="line">        EditText etNum;  </span><br><span class="line">        CalThread calThread;  </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">            <span class="keyword">public</span> Handler mHandler;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">                Looper.prepare();  </span><br><span class="line">                mHandler = <span class="keyword">new</span> Handler()&#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;  </span><br><span class="line">                        <span class="keyword">if</span> (msg.what == <span class="number">0x123</span>) &#123;  </span><br><span class="line">                            <span class="keyword">int</span> upper = msg.getData().getInt(UPPER_NUM);  </span><br><span class="line">                            List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">                            <span class="comment">//计算从2开始，到upper的所有质数  </span></span><br><span class="line">                            outer:  </span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= upper; i++) &#123;  </span><br><span class="line">                                    <span class="comment">//用i除以从2开始，到i的平方根的所有数  </span></span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++) &#123;  </span><br><span class="line">                                        <span class="comment">//如果可以整除，表明这个数不是质数  </span></span><br><span class="line">                                        <span class="keyword">if</span> (i != <span class="number">2</span> &amp;&amp; i % j == <span class="number">0</span>) &#123;  </span><br><span class="line">                                            <span class="keyword">continue</span> outer;  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                    nums.add(i);  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            <span class="comment">//使用Toast显示统计出来的所有质数  </span></span><br><span class="line">                            Toast.makeText(CalPrime.<span class="keyword">this</span>, nums.toString(), Toast.LENGTH_LONG).show();  </span><br><span class="line">                              </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;;  </span><br><span class="line">                Looper.loop();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.main_activity);  </span><br><span class="line">        etNum = (EditText)findViewById(R.id.etNum);  </span><br><span class="line">        CalThread calThread = <span class="keyword">new</span> CalThread();  </span><br><span class="line">        calThread.start();<span class="comment">//启动新线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//为按钮的点击事件提供事件处理函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(View source)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//创建消息  </span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message();  </span><br><span class="line">        msg.what = <span class="number">0x123</span>;  </span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();  </span><br><span class="line">        bundle.putInt(UPPER_NUM, Integer.parseInt(etNum.getText().toString()));  </span><br><span class="line">        msg.setData(bundle);  </span><br><span class="line">        <span class="comment">//向新线程中的Handler发送消息  </span></span><br><span class="line">        calThread.mHandler.sendMessage(msg);  </span><br><span class="line">          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: 在子线程中是不能直接Toast的，因为在Toast内部有一个Handler，在子线程中是不可以直接new一个Handler的，要放在Looper.prepare和Looper.loop方法之间。</strong></p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>首先我们先看一下官方的描述：</p>
<blockquote>
<p>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called.</p>
</blockquote>
<p>大致意思是HandlerThread能够新建拥有Looper的线程。这个Looper能够用来新建其他的Handler。（线程中的Looper）需要注意的是，新建的时候需要被回调。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>之前我们在子线程中发送消息，然后在主线程中接收消息，用于更新UI,但是我们很多时候是在子线程中处理消息，但子线程中不能直接新建一个Handler对象，这时候就用到HandlerThread了。</p>
<p>关于子线程为什么不能更新UI，请参考<a href="https://blog.csdn.net/self_study/article/details/50548894" target="_blank" rel="noopener">这篇文章</a></p>
<p>为什么要在子线程中处理消息呢？必然是执行耗时操作。举个例子，数据实时更新，我们每10秒需要切换一下显示的数据，如果我们将这种长时间的反复调用操作放到UI线程中，虽说可以执行，但是这样的操作多了之后，很容易会让UI线程卡顿甚至崩溃。 </p>
<p>HandlerThread继承自Thread，一般适应的场景，便是集Thread和Handler之所长，适用于会长时间在后台运行，并且间隔时间内（或适当情况下）会调用的情况，比如上面所说的实时更新。</p>
<blockquote>
<p>其实使用HandlerThread的效果和使用Thread+Handler差不多。不过后者对开发者的要求更高。</p>
</blockquote>
<p>Demo：每2秒更新一下UI。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tvMain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line">    <span class="comment">//子线程中的handler</span></span><br><span class="line">    <span class="keyword">private</span> Handler mThreadHandler;</span><br><span class="line">    <span class="comment">//UI线程中的handler</span></span><br><span class="line">    <span class="keyword">private</span> Handler mMainHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以防退出界面后Handler还在执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isUpdateInfo;</span><br><span class="line">    <span class="comment">//用以表示该handler的常熟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_UPDATE_INFO = <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        tvMain = (TextView) findViewById(R.id.tv_main);</span><br><span class="line"></span><br><span class="line">        initThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"check-message-coming"</span>);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">        mThreadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper())</span><br><span class="line">        &#123;</span><br><span class="line">               <span class="comment">//这个方法运行在HandlerThread线程中</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                update();<span class="comment">//模拟数据更新</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isUpdateInfo)</span><br><span class="line">                    mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//模拟耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            mMainHandler.post(<span class="keyword">new</span> Runnable()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    String result = <span class="string">"每隔2秒更新一下数据："</span>;</span><br><span class="line">                    result += Math.random();</span><br><span class="line">                    tvMain.setText(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">//开始查询</span></span><br><span class="line">        isUpdateInfo = <span class="keyword">true</span>;</span><br><span class="line">        mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        <span class="comment">//停止查询</span></span><br><span class="line">        <span class="comment">//以防退出界面后Handler还在执行</span></span><br><span class="line">        isUpdateInfo = <span class="keyword">false</span>;</span><br><span class="line">        mThreadHandler.removeMessages(MSG_UPDATE_INFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        mHandlerThread.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>这里的new Handler(mHandlerThread.getLooper())，将HandlerThread的Looper对象作为参数，所以这里的 public void handleMessage(Message msg)就运行在HandlerThread线程中，且在一个无限循环中，就可以在这里进行耗时操作。所以如果不手动终止循环，就会占用系统资源，所以在onDestroy方法里调用了HandlerThread的quit方法退出循环，然后子线程才能结束。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HandlerThread只是继承了Thread并且有一个Looper变量的一个类，还是要结合Handler使用，只是在实例化Handler对象的时候传进去了一个HandlerThread.getLooper()类型的参数，然后在handleMessage中就可以执行耗时操作了。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-07T04:19:16.000Z"><a href="/2018/04/07/BroadCast/">2018-04-07</a></time>
        
  
    <h1 class="title"><a href="/2018/04/07/BroadCast/">BroadCast</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#广播两种注册方式的区别"><span class="toc-text"><a href="#&#x5E7F;&#x64AD;&#x4E24;&#x79CD;&#x6CE8;&#x518C;&#x65B9;&#x5F0F;&#x7684;&#x533A;&#x522B;" class="headerlink" title="&#x5E7F;&#x64AD;&#x4E24;&#x79CD;&#x6CE8;&#x518C;&#x65B9;&#x5F0F;&#x7684;&#x533A;&#x522B;"></a>&#x5E7F;&#x64AD;&#x4E24;&#x79CD;&#x6CE8;&#x518C;&#x65B9;&#x5F0F;&#x7684;&#x533A;&#x522B;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态注册：即用代码动态的注册、注销广播"><span class="toc-text"><a href="#&#x52A8;&#x6001;&#x6CE8;&#x518C;&#xFF1A;&#x5373;&#x7528;&#x4EE3;&#x7801;&#x52A8;&#x6001;&#x7684;&#x6CE8;&#x518C;&#x3001;&#x6CE8;&#x9500;&#x5E7F;&#x64AD;" class="headerlink" title="&#x52A8;&#x6001;&#x6CE8;&#x518C;&#xFF1A;&#x5373;&#x7528;&#x4EE3;&#x7801;&#x52A8;&#x6001;&#x7684;&#x6CE8;&#x518C;&#x3001;&#x6CE8;&#x9500;&#x5E7F;&#x64AD;"></a>&#x52A8;&#x6001;&#x6CE8;&#x518C;&#xFF1A;&#x5373;&#x7528;&#x4EE3;&#x7801;&#x52A8;&#x6001;&#x7684;&#x6CE8;&#x518C;&#x3001;&#x6CE8;&#x9500;&#x5E7F;&#x64AD;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态广播：把广播写死在manifest-xml中"><span class="toc-text"><a href="#&#x9759;&#x6001;&#x5E7F;&#x64AD;&#xFF1A;&#x628A;&#x5E7F;&#x64AD;&#x5199;&#x6B7B;&#x5728;manifest-xml&#x4E2D;" class="headerlink" title="&#x9759;&#x6001;&#x5E7F;&#x64AD;&#xFF1A;&#x628A;&#x5E7F;&#x64AD;&#x5199;&#x6B7B;&#x5728;manifest.xml&#x4E2D;"></a>&#x9759;&#x6001;&#x5E7F;&#x64AD;&#xFF1A;&#x628A;&#x5E7F;&#x64AD;&#x5199;&#x6B7B;&#x5728;manifest.xml&#x4E2D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两者的区别"><span class="toc-text"><a href="#&#x4E24;&#x8005;&#x7684;&#x533A;&#x522B;" class="headerlink" title="&#x4E24;&#x8005;&#x7684;&#x533A;&#x522B;"></a>&#x4E24;&#x8005;&#x7684;&#x533A;&#x522B;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特别注意"><span class="toc-text"><a href="#&#x7279;&#x522B;&#x6CE8;&#x610F;" class="headerlink" title="&#x7279;&#x522B;&#x6CE8;&#x610F;"></a>&#x7279;&#x522B;&#x6CE8;&#x610F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广播的类型"><span class="toc-text"><a href="#&#x5E7F;&#x64AD;&#x7684;&#x7C7B;&#x578B;" class="headerlink" title="&#x5E7F;&#x64AD;&#x7684;&#x7C7B;&#x578B;"></a>&#x5E7F;&#x64AD;&#x7684;&#x7C7B;&#x578B;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-普通广播"><span class="toc-text"><a href="#1-&#x666E;&#x901A;&#x5E7F;&#x64AD;" class="headerlink" title="1 &#x666E;&#x901A;&#x5E7F;&#x64AD;"></a>1 &#x666E;&#x901A;&#x5E7F;&#x64AD;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-系统广播"><span class="toc-text"><a href="#2-&#x7CFB;&#x7EDF;&#x5E7F;&#x64AD;" class="headerlink" title="2 &#x7CFB;&#x7EDF;&#x5E7F;&#x64AD;"></a>2 &#x7CFB;&#x7EDF;&#x5E7F;&#x64AD;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序广播（Ordered-Broadcast）"><span class="toc-text"><a href="#&#x6709;&#x5E8F;&#x5E7F;&#x64AD;&#xFF08;Ordered-Broadcast&#xFF09;" class="headerlink" title="&#x6709;&#x5E8F;&#x5E7F;&#x64AD;&#xFF08;Ordered Broadcast&#xFF09;"></a>&#x6709;&#x5E8F;&#x5E7F;&#x64AD;&#xFF08;Ordered Broadcast&#xFF09;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-App应用内广播（Local-Broadcast）"><span class="toc-text"><a href="#4-App&#x5E94;&#x7528;&#x5185;&#x5E7F;&#x64AD;&#xFF08;Local-Broadcast&#xFF09;" class="headerlink" title="4 App&#x5E94;&#x7528;&#x5185;&#x5E7F;&#x64AD;&#xFF08;Local Broadcast&#xFF09;"></a>4 App&#x5E94;&#x7528;&#x5185;&#x5E7F;&#x64AD;&#xFF08;Local Broadcast&#xFF09;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广播的生命周期"><span class="toc-text"><a href="#&#x5E7F;&#x64AD;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="&#x5E7F;&#x64AD;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>&#x5E7F;&#x64AD;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#广播接收器的生命周期"><span class="toc-text"><a href="#&#x5E7F;&#x64AD;&#x63A5;&#x6536;&#x5668;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="&#x5E7F;&#x64AD;&#x63A5;&#x6536;&#x5668;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>&#x5E7F;&#x64AD;&#x63A5;&#x6536;&#x5668;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广播发送者的生命周期"><span class="toc-text"><a href="#&#x5E7F;&#x64AD;&#x53D1;&#x9001;&#x8005;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="&#x5E7F;&#x64AD;&#x53D1;&#x9001;&#x8005;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>&#x5E7F;&#x64AD;&#x53D1;&#x9001;&#x8005;&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在onReceived方法中不能做任何耗时操作"><span class="toc-text"><a href="#&#x5728;onReceived&#x65B9;&#x6CD5;&#x4E2D;&#x4E0D;&#x80FD;&#x505A;&#x4EFB;&#x4F55;&#x8017;&#x65F6;&#x64CD;&#x4F5C;" class="headerlink" title="&#x5728;onReceived&#x65B9;&#x6CD5;&#x4E2D;&#x4E0D;&#x80FD;&#x505A;&#x4EFB;&#x4F55;&#x8017;&#x65F6;&#x64CD;&#x4F5C;"></a>&#x5728;onReceived&#x65B9;&#x6CD5;&#x4E2D;&#x4E0D;&#x80FD;&#x505A;&#x4EFB;&#x4F55;&#x8017;&#x65F6;&#x64CD;&#x4F5C;</span></a></li></ol>
    </div>

        <p>&gt;</p>
<h3 id="广播两种注册方式的区别"><a href="#广播两种注册方式的区别" class="headerlink" title="广播两种注册方式的区别"></a>广播两种注册方式的区别</h3><p>今天介绍一下Android的四大组件之一的BroadCastReceiver，即广播。广播类似于JAVA设计模式中的观察者模式，即当被观察者数据变化的时候，会去通知观察者做相应处理。这里也是一样，当发出广播的时候，那么注册过该广播的人，就能收到这个广播，进而做一些工作。</p>
<p>上面说的广播注册，在Andro的广播作为例子，看看这两种方式的具体用法。动态注册不许要在manifest文件里写任何东西（除了需要的权id中有两种方式，即动态注册(代码注册)、静态注册(清单文件注册)，下面我以Android中网络状态变化发出限）。</p>
<hr>
<h4 id="动态注册：即用代码动态的注册、注销广播"><a href="#动态注册：即用代码动态的注册、注销广播" class="headerlink" title="动态注册：即用代码动态的注册、注销广播"></a>动态注册：即用代码动态的注册、注销广播</h4><p>registerReceiver<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicInternetActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternetDynamicBroadCastReceiver mReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dynamic_lock_screen);</span><br><span class="line"></span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">        mReceiver = <span class="keyword">new</span> InternetDynamicBroadCastReceiver();</span><br><span class="line">        <span class="keyword">this</span>.registerReceiver(<span class="keyword">new</span> InternetDynamicBroadCastReceiver(), filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternetDynamicBroadCastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(DynamicInternetActivity.<span class="keyword">this</span>,<span class="string">"网络发生了变化"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> 注意：上面在onDestroy方法中，必须注销广播，否则有内存泄漏的风险！！！</strong></p>
<h4 id="静态广播：把广播写死在manifest-xml中"><a href="#静态广播：把广播写死在manifest-xml中" class="headerlink" title="静态广播：把广播写死在manifest.xml中"></a>静态广播：把广播写死在manifest.xml中</h4><p>只需在广播接收器的清单文件里注册广播的接收事件<br>没有和特定的Activity绑定<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">        &lt;!--&lt;action android:name=<span class="string">"ConnectivityManager.CONNECTIVITY_ACTION"</span>/&gt;<span class="comment">//这样写是不对的--&gt;</span></span><br><span class="line">        &lt;action android:name=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>/&gt;<span class="comment">//此处必需指定action，否则监听不到</span></span><br><span class="line">    &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后重写广播接收器的onReceive方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternetStaticBroadCastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context,<span class="string">"网络发生了变化"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>　动态注册的广播会受Activity的生命周期的影响， 当Activity销毁的时候，广播就失效了。<br>  静态注册不需要和特定的Activity绑定，即使程序没有启动也可以接收广播</p>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul>
<li>动态广播最好在Activity 的 onResume()注册、onPause()注销</li>
<li>对于动态广播，有注册就必然得有注销，否则会导致内存泄露</li>
<li>重复注册、重复注销也不允许<blockquote>
<p>不在onCreate() &amp; onDestory() 或 onStart() &amp; onStop()注册、注销是因为：<br>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。导致广播无法注销，重复注册，造成内存泄漏。</p>
<h4 id="广播的类型"><a href="#广播的类型" class="headerlink" title="广播的类型"></a>广播的类型</h4><p>广播的类型主要分为5类：</p>
</blockquote>
</li>
</ul>
<ol>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）</li>
<li>App应用内广播（Local Broadcast）</li>
</ol>
<h4 id="1-普通广播"><a href="#1-普通广播" class="headerlink" title="1 普通广播"></a>1 普通广播</h4><p>即 开发者自身定义 intent的广播（最常用）。发送广播使用如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。<br><strong>若发送广播有相应权限，那么广播接收者也需要相应权限</strong></p>
</blockquote>
<h4 id="2-系统广播"><a href="#2-系统广播" class="headerlink" title="2 系统广播"></a>2 系统广播</h4><ul>
<li>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播</li>
<li>每个广播都有特定的Intent - Filter（包括具体的action），Android系统广播action如下：</li>
</ul>
<table>
<thead>
<tr>
<th>系统操作</th>
<th style="text-align:center">Action </th>
</tr>
</thead>
<tbody>
<tr>
<td>监听网络变化</td>
<td style="text-align:center">android.net.conn.CONNECTIVITY_CHANGE</td>
</tr>
<tr>
<td>关闭或打开飞行模式</td>
<td style="text-align:center">Intent.ACTION_AIRPLANE_MODE_CHANGED</td>
</tr>
<tr>
<td>充电时或电量发生变化</td>
<td style="text-align:center">Intent.ACTION_BATTERY_CHANGED</td>
</tr>
<tr>
<td>电池电量低</td>
<td style="text-align:center">Intent.ACTION_BATTERY_LOW</td>
</tr>
<tr>
<td>电池电量充足（即从电量低变化到饱满时会发出广播</td>
<td style="text-align:center">Intent.ACTION_BATTERY_OKAY</td>
</tr>
<tr>
<td>系统启动完成后(仅广播一次)</td>
<td style="text-align:center">Intent.ACTION_BOOT_COMPLETED</td>
</tr>
<tr>
<td>按下照相时的拍照按键(硬件按键)时</td>
<td style="text-align:center">Intent.ACTION_CAMERA_BUTTON</td>
</tr>
<tr>
<td>屏幕锁屏</td>
<td style="text-align:center">ntent.ACTION_CLOSE_SYSTEM_DIALOGS</td>
</tr>
<tr>
<td>设备当前设置被改变时(界面语言、设备方向等)</td>
<td style="text-align:center">Intent.ACTION_CONFIGURATION_CHANGED</td>
</tr>
</tbody>
</table>
<p>还有很多，就不一一列举了</p>
<p><strong>当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播</strong></p>
<h4 id="有序广播（Ordered-Broadcast）"><a href="#有序广播（Ordered-Broadcast）" class="headerlink" title="有序广播（Ordered Broadcast）"></a>有序广播（Ordered Broadcast）</h4><blockquote>
<p>发送出去的广播被广播接收者按照先后顺序接收<br>有序是针对广播接收者而言的</p>
</blockquote>
<p>广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者）</p>
<ol>
<li>按照Priority属性值从大-小排序；</li>
<li>Priority属性相同者，动态注册的广播优先；</li>
</ol>
<p>在广播接收器内指明优先级<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter android:priority=<span class="string">"100"</span> &gt;</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ol>
<li>接收广播按顺序接收</li>
<li>先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播；</li>
<li>先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</li>
</ol>
<p>使用方式：<br>有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(intent);</span><br></pre></td></tr></table></figure></p>
<p>截断广播只需要在广播接收器的onReceive()方法中写入abortBroadcast();就好了。</p>
<h4 id="4-App应用内广播（Local-Broadcast）"><a href="#4-App应用内广播（Local-Broadcast）" class="headerlink" title="4 App应用内广播（Local Broadcast）"></a>4 App应用内广播（Local Broadcast）</h4><blockquote>
<p>Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）</p>
</blockquote>
<p>可能出现的问题：</p>
<ul>
<li>其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；</li>
<li>其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息；<br>即会出现安全性 &amp; 效率性的问题。</li>
</ul>
<p>解决办法：<br>使用App应用内广播（Local Broadcast）</p>
<blockquote>
<ol>
<li>App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。<br></li>
<li>相比于全局广播（普通广播），App应用内广播优势体现在：安全性高 &amp; 效率高</li>
</ol>
</blockquote>
<p>使用方法：</p>
<ul>
<li>具体使用1 - 将全局广播设置成局部广播</li>
</ul>
<ol>
<li>注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；</li>
<li>在广播发送和接收时，增设相应权限permission，用于权限验证；</li>
<li>发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。</li>
</ol>
<blockquote>
<p>通过intent.setPackage(packageName)指定报名</p>
</blockquote>
<ul>
<li>具体使用2 - 使用封装好的LocalBroadcastManager类</li>
</ul>
<p>使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例<br><strong>注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</strong></p>
<p>广播接收器的写法和普通广播一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver(); </span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line">作者：Carson_Ho</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/ca3d87a4cdf3</span></span><br><span class="line">來源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<h3 id="广播的生命周期"><a href="#广播的生命周期" class="headerlink" title="广播的生命周期"></a>广播的生命周期</h3><h4 id="广播接收器的生命周期"><a href="#广播接收器的生命周期" class="headerlink" title="广播接收器的生命周期"></a>广播接收器的生命周期</h4><p>当一个broadcast信息到达该receiver，Android调用它的onReceive()方法并将含有该广播信息的intent 对象传递它。Broadcast receiver仅仅在执行该方法时才被认为是活跃的。当onReceive()返回后，它又处于非活跃状态。也就是说，它的生命周期为从回调onReceive()方法开始到该方法返回结果后结束。</p>
<p>广播接收器的生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息。当该broadcast信息的响应很耗时时会存在问题，这时应该单独给他一个线程运行，而不是在其他组件所在的与用户交互的线程中。如果onReceive()生成该线程后返回，整个进程，包括那个新的线程，都被判断为非活跃的（除非该进程里的其他组件是活跃的），归入了可以被杀死的一类。解决该问题的答案是使用onReceive()开始一个service，让该service进行该处理，那样一来，系统就会知道该进程里仍有活跃的处理在进行。</p>
<h4 id="广播发送者的生命周期"><a href="#广播发送者的生命周期" class="headerlink" title="广播发送者的生命周期"></a>广播发送者的生命周期</h4><p>发送的广播，只有在发送的那一个时刻有效。</p>
<h3 id="在onReceived方法中不能做任何耗时操作"><a href="#在onReceived方法中不能做任何耗时操作" class="headerlink" title="在onReceived方法中不能做任何耗时操作"></a>在onReceived方法中不能做任何耗时操作</h3><p>首先看静态注册的时候，onReceived怎么执行的：</p>
<ol>
<li>启动程序进程 </li>
<li>启动ui线程和调用广播的 onReceive(Context context, Intent intent)方法 </li>
<li>onReceive方法返回后，进程和线程处于等待状态；系统任意时刻可以终止和回收该线程和进程占有资源（内存）</li>
</ol>
<p>如果：在onReceive开启一个线程做任务，任务未做完系统有可能回收进程，做任务的线程就没有对应的进程上下文，会被回收，任务就有可能未完成。</p>
<p>就是onReceived生命周期很短，如果开启线程的receiver没了，这些线程很容易就会被回收。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-04-03T13:44:07.000Z"><a href="/2018/04/03/链家面经/">2018-04-03</a></time>
        
  
    <h1 class="title"><a href="/2018/04/03/链家面经/">链家面经</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android方面"><span class="toc-text"><a href="#Android&#x65B9;&#x9762;" class="headerlink" title="Android&#x65B9;&#x9762;"></a>Android&#x65B9;&#x9762;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的生命周期"><span class="toc-text"><a href="#Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的四种启动模式"><span class="toc-text"><a href="#Activity&#x7684;&#x56DB;&#x79CD;&#x542F;&#x52A8;&#x6A21;&#x5F0F;" class="headerlink" title="Activity&#x7684;&#x56DB;&#x79CD;&#x542F;&#x52A8;&#x6A21;&#x5F0F;"></a>Activity&#x7684;&#x56DB;&#x79CD;&#x542F;&#x52A8;&#x6A21;&#x5F0F;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-通过标签中的launchMode属性设定"><span class="toc-text"><a href="#1-&#x901A;&#x8FC7;&#x6807;&#x7B7E;&#x4E2D;&#x7684;launchMode&#x5C5E;&#x6027;&#x8BBE;&#x5B9A;" class="headerlink" title="1 &#x901A;&#x8FC7;&#x6807;&#x7B7E;&#x4E2D;&#x7684;launchMode&#x5C5E;&#x6027;&#x8BBE;&#x5B9A;"></a>1 &#x901A;&#x8FC7;<activity>&#x6807;&#x7B7E;&#x4E2D;&#x7684;launchMode&#x5C5E;&#x6027;&#x8BBE;&#x5B9A;</activity></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在一个App启动另一个App中的Activity"><span class="toc-text"><a href="#&#x5728;&#x4E00;&#x4E2A;App&#x542F;&#x52A8;&#x53E6;&#x4E00;&#x4E2A;App&#x4E2D;&#x7684;Activity" class="headerlink" title="&#x5728;&#x4E00;&#x4E2A;App&#x542F;&#x52A8;&#x53E6;&#x4E00;&#x4E2A;App&#x4E2D;&#x7684;Activity"></a>&#x5728;&#x4E00;&#x4E2A;App&#x542F;&#x52A8;&#x53E6;&#x4E00;&#x4E2A;App&#x4E2D;&#x7684;Activity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的参数"><span class="toc-text"><a href="#Activity&#x7684;&#x53C2;&#x6570;" class="headerlink" title="Activity&#x7684;&#x53C2;&#x6570;"></a>Activity&#x7684;&#x53C2;&#x6570;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#taskAffinity"><span class="toc-text"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#清空返回栈"><span class="toc-text"><a href="#&#x6E05;&#x7A7A;&#x8FD4;&#x56DE;&#x6808;" class="headerlink" title="&#x6E05;&#x7A7A;&#x8FD4;&#x56DE;&#x6808;"></a>&#x6E05;&#x7A7A;&#x8FD4;&#x56DE;&#x6808;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alwaysRetainTaskState"><span class="toc-text"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a>alwaysRetainTaskState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clearTaskOnLaunch"><span class="toc-text"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a>clearTaskOnLaunch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finishOnTaskLaunch"><span class="toc-text"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a>finishOnTaskLaunch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service"><span class="toc-text"><a href="#Service" class="headerlink" title="Service"></a>Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触摸事件传递机制"><span class="toc-text"><a href="#&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x4F20;&#x9012;&#x673A;&#x5236;" class="headerlink" title="&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x4F20;&#x9012;&#x673A;&#x5236;"></a>&#x89E6;&#x6478;&#x4E8B;&#x4EF6;&#x4F20;&#x9012;&#x673A;&#x5236;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread"><span class="toc-text"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java方面"><span class="toc-text"><a href="#Java&#x65B9;&#x9762;" class="headerlink" title="Java&#x65B9;&#x9762;"></a>Java&#x65B9;&#x9762;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#谈一谈对ClassLoader的理解"><span class="toc-text"><a href="#&#x8C08;&#x4E00;&#x8C08;&#x5BF9;ClassLoader&#x7684;&#x7406;&#x89E3;" class="headerlink" title="&#x8C08;&#x4E00;&#x8C08;&#x5BF9;ClassLoader&#x7684;&#x7406;&#x89E3;"></a>&#x8C08;&#x4E00;&#x8C08;&#x5BF9;ClassLoader&#x7684;&#x7406;&#x89E3;</span></a></li></ol></li></ol>
    </div>

        <blockquote>
<p>废话不多说，今天面试又失败了，很多基础性的问题又没有回答上来，先写一下android方面的，再说Java方面的</p>
</blockquote>
<h2 id="Android方面"><a href="#Android方面" class="headerlink" title="Android方面"></a>Android方面</h2><h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><p>生命周期方法<br><img src="/2018/04/03/链家面经/image.png" alt=""></p>
<p>onStart和onResume的区别是，虽然两个阶段都可见，但是onStart时，界面还没有获取焦点，onResume时，用户获取了焦点，onPause失去焦点，onPause和onStop的区别是onPause可见而onStop完全不可见，两者都失去了焦点，在经历了onStop方法后，如果再回到这个Activity，将会执行onRestart方法，onStart，onResume。</p>
<h3 id="Activity的四种启动模式"><a href="#Activity的四种启动模式" class="headerlink" title="Activity的四种启动模式"></a>Activity的四种启动模式</h3><h4 id="1-通过标签中的launchMode属性设定"><a href="#1-通过标签中的launchMode属性设定" class="headerlink" title="1 通过标签中的launchMode属性设定"></a>1 通过<activity>标签中的launchMode属性设定</activity></h4><ol>
<li>standard<br>默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中，永远不会调用onNewIntent()。  </li>
<li>singleTop<br>如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。  </li>
<li>singleTask<br>如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。   <ol>
<li>singleInstance<br>在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦改模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。  </li>
</ol>
</li>
</ol>
<ol>
<li>启动模式下各方法的调用情况</li>
</ol>
<p>singleInstance:<br>第一次进入：onCreate onStart<br>在栈顶再次进入： onNewIntent<br> 不在栈顶再次进入：onNewIntent onRestart onStart<br>按home键再次进入:onRestart onStart<br>按返回键：onRestart onStart</p>
<p>standard:<br>第一次进入：onCreate onStart<br>在栈顶再次进入： onCreate onStart<br>不在栈顶再次进入：onCreate onStart<br>按home键再次进入:onRestart onStart<br>按返回键：onRestart onStart</p>
<p>singleTop:<br>第一次进入：onCreate onStart<br>在栈顶再次进入：onNewIntent<br>不在栈顶再次进入：onCreate onStart<br>按home键再次进入:onRestart onStart<br>按返回键：onRestart onStart</p>
<p>singleTask:<br>第一次进入：onCreate onStart<br>在栈顶再次进入：onNewIntent<br>不在栈顶再次进入：onNewIntent onRestart onStart<br>按home键再次进入:onRestart onStart<br>按返回键：onRestart onStart</p>
<p><strong> 特别说明，当为一个Activity设置为singleInstance时，当从一个Activity跳转到这个Activity时，无论那个Activity在不在这个应用里，当按下home键，再打开该应用，显示的都是跳转到这个Activity之前的Activity，即调用者Activity。 只要设置了这个属性之后，该任务中就只有这一个Activity</strong></p>
<ol>
<li>关于onNewIntent<br>可以发现 onNewIntent 是在界面没有重新创建时调用的，从A跳过来的Intent依然保存着，onNewIntent 从字面意思来理解重新创建了一个Intent 来接收新的意图,可以在onNewIntent方法中重新设置Intent。<br>如果该Activity通过Intent启动，而且重用该Activity实例的时候，这个方法将会被调用，可以在这里对intent传进来的数据进行处理，重写onNewIntent方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">        setIntent(intent);</span><br><span class="line">        Log.e(<span class="string">"BActivity"</span>,<span class="string">"onNewIntent"</span>+intent.getStringExtra(<span class="string">"cyy"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在一个App启动另一个App中的Activity"><a href="#在一个App启动另一个App中的Activity" class="headerlink" title="在一个App启动另一个App中的Activity"></a>在一个App启动另一个App中的Activity</h3><p>第一种方法：完全可以用intent的隐式启动方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setAction(<span class="string">"bbb"</span>);</span><br><span class="line">intent.addCategory(<span class="string">"nnnn"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二种方法：intent.setClassName(app包名，包名.类名);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.setClassName(<span class="string">"com.example.droodsunny.singleinatancetset"</span>,<span class="string">"com.example.droodsunny.singleinatancetset.MainActivity"</span>);</span><br></pre></td></tr></table></figure></p>
<p>第三种方法：ComponentName<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ComponentName componentName=<span class="keyword">new</span> ComponentName(<span class="string">"com.example.droodsunny.singleinatancetset"</span>,</span><br><span class="line"><span class="string">"com.example.droodsunny.singleinatancetset.MainActivity"</span>);</span><br><span class="line"> intent.setComponent(componentName);</span><br></pre></td></tr></table></figure></p>
<p><strong> 如果启动一个APP的主界面不能用第一种方法 </strong></p>
<h3 id="Activity的参数"><a href="#Activity的参数" class="headerlink" title="Activity的参数"></a>Activity的参数</h3><p>在<activity>元素中，有以下几个属性是可以使用的：</activity></p>
<ol>
<li>taskAffinity</li>
<li>launchMode</li>
<li>allowTaskReparenting</li>
<li>clearTaskOnLaunch</li>
<li>alwaysRetainTaskState</li>
<li>finishOnTaskLaunch</li>
</ol>
<h4 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h4><blockquote>
<p>taskAffinity可以显示的指定Activity所在的返回栈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".lancumode.BActivity"</span></span><br><span class="line">            android:launchMode=<span class="string">"singleTask"</span></span><br><span class="line">            android:taskAffinity=<span class="string">"wdwd.cyy"</span>&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>singleInstancez:即使不改变taskAffinity 也会改变takid<br>另外taskAffinity 可以与 android:allowTaskReparenting=”true”一起用。</p>
<blockquote>
<p>allowTaskReparenting用来标记Activity能否从启动的Task移动到taskAffinity指定的Task，默认是继承至application中的allowTaskReparenting=false，如果为true，则表示可以更换；false表示不可以。<br>当设置为true时，当一个Activity被另一个应用打开时，如果这个activity没有被销毁，那当打开这个Activity所在的应用时，就会立即显示该Activity，因为这个Activity和这个任务有相同的affinity值，而且退出的时候还会回到主Activity，如果在该任务中已经存在了该Activity实例了，那么打开这个APP之后这个Activity会在上一个Activity之上，也就是说不会重用那个实例。</p>
</blockquote>
<h4 id="清空返回栈"><a href="#清空返回栈" class="headerlink" title="清空返回栈"></a>清空返回栈</h4><p>如果用户将任务切换到后台之后过了很长一段时间，系统会将这个任务中除了最底层的那个Activity之外的其它所有Activity全部清除掉。当用户重新回到这个任务的时候，最底层的那个Activity将得到恢复。这个是系统默认的行为，因为既然过了这么长的一段时间，用户很有可能早就忘记了当时正在做什么，那么重新回到这个任务的时候，基本上应该是要去做点新的事情了。</p>
<h4 id="alwaysRetainTaskState"><a href="#alwaysRetainTaskState" class="headerlink" title="alwaysRetainTaskState"></a>alwaysRetainTaskState</h4><p>如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生，任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。</p>
<h4 id="clearTaskOnLaunch"><a href="#clearTaskOnLaunch" class="headerlink" title="clearTaskOnLaunch"></a>clearTaskOnLaunch</h4><p>如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。简单来讲，就是一种和alwaysRetainTaskState完全相反的工作模式，它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。</p>
<h4 id="finishOnTaskLaunch"><a href="#finishOnTaskLaunch" class="headerlink" title="finishOnTaskLaunch"></a>finishOnTaskLaunch</h4><p>这个属性和clearTaskOnLaunch是比较类似的，不过它不是作用于整个任务上的，而是作用于单个Activity上。如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><blockquote>
<p>关于service的详细讲解在这篇文章里</p>
</blockquote>
<p><a href="http://sshpro.space/2018/03/31/service/" target="_blank" rel="noopener">在这里</a><br></p>
<p><strong> 在Service里进行耗时操作是需要开启新线程的</strong></p>
<h3 id="触摸事件传递机制"><a href="#触摸事件传递机制" class="headerlink" title="触摸事件传递机制"></a>触摸事件传递机制</h3><p>由于篇幅很长，所以在<a href="http://sshpro.space/2018/04/07/TouchEventDispatch/" target="_blank" rel="noopener">这篇文章</a>进行讲解。</p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>由于篇幅很长，所以在<a href="http://sshpro.space/2018/04/07/HandlerThread/" target="_blank" rel="noopener">这篇文章</a>进行讲解。</p>
<h2 id="Java方面"><a href="#Java方面" class="headerlink" title="Java方面"></a>Java方面</h2><h3 id="谈一谈对ClassLoader的理解"><a href="#谈一谈对ClassLoader的理解" class="headerlink" title="谈一谈对ClassLoader的理解"></a>谈一谈对ClassLoader的理解</h3>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-03-31T06:44:35.000Z"><a href="/2018/03/31/service/">2018-03-31</a></time>
        
  
    <h1 class="title"><a href="/2018/03/31/service/">service</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一篇讲了service的创建和两种启动方法"><span class="toc-text"><a href="#&#x7B2C;&#x4E00;&#x7BC7;&#x8BB2;&#x4E86;service&#x7684;&#x521B;&#x5EFA;&#x548C;&#x4E24;&#x79CD;&#x542F;&#x52A8;&#x65B9;&#x6CD5;" class="headerlink" title="&#x7B2C;&#x4E00;&#x7BC7;&#x8BB2;&#x4E86;service&#x7684;&#x521B;&#x5EFA;&#x548C;&#x4E24;&#x79CD;&#x542F;&#x52A8;&#x65B9;&#x6CD5;"></a>&#x7B2C;&#x4E00;&#x7BC7;&#x8BB2;&#x4E86;service&#x7684;&#x521B;&#x5EFA;&#x548C;&#x4E24;&#x79CD;&#x542F;&#x52A8;&#x65B9;&#x6CD5;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用bindservice启动时的细节实现"><span class="toc-text"><a href="#&#x4F7F;&#x7528;bindservice&#x542F;&#x52A8;&#x65F6;&#x7684;&#x7EC6;&#x8282;&#x5B9E;&#x73B0;" class="headerlink" title="&#x4F7F;&#x7528;bindservice&#x542F;&#x52A8;&#x65F6;&#x7684;&#x7EC6;&#x8282;&#x5B9E;&#x73B0;"></a>&#x4F7F;&#x7528;bindservice&#x542F;&#x52A8;&#x65F6;&#x7684;&#x7EC6;&#x8282;&#x5B9E;&#x73B0;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将我的一些困惑和理解写在下面"><span class="toc-text"><a href="#&#x5C06;&#x6211;&#x7684;&#x4E00;&#x4E9B;&#x56F0;&#x60D1;&#x548C;&#x7406;&#x89E3;&#x5199;&#x5728;&#x4E0B;&#x9762;" class="headerlink" title="&#x5C06;&#x6211;&#x7684;&#x4E00;&#x4E9B;&#x56F0;&#x60D1;&#x548C;&#x7406;&#x89E3;&#x5199;&#x5728;&#x4E0B;&#x9762;"></a>&#x5C06;&#x6211;&#x7684;&#x4E00;&#x4E9B;&#x56F0;&#x60D1;&#x548C;&#x7406;&#x89E3;&#x5199;&#x5728;&#x4E0B;&#x9762;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于Service的实例化"><span class="toc-text"><a href="#&#x5173;&#x4E8E;Service&#x7684;&#x5B9E;&#x4F8B;&#x5316;" class="headerlink" title="&#x5173;&#x4E8E;Service&#x7684;&#x5B9E;&#x4F8B;&#x5316;"></a>&#x5173;&#x4E8E;Service&#x7684;&#x5B9E;&#x4F8B;&#x5316;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#onBinder的用法"><span class="toc-text"><a href="#onBinder&#x7684;&#x7528;&#x6CD5;" class="headerlink" title="onBinder&#x7684;&#x7528;&#x6CD5;"></a>onBinder&#x7684;&#x7528;&#x6CD5;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#客户端"><span class="toc-text"><a href="#&#x5BA2;&#x6237;&#x7AEF;" class="headerlink" title="&#x5BA2;&#x6237;&#x7AEF;"></a>&#x5BA2;&#x6237;&#x7AEF;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#服务器端"><span class="toc-text"><a href="#&#x670D;&#x52A1;&#x5668;&#x7AEF;" class="headerlink" title="&#x670D;&#x52A1;&#x5668;&#x7AEF;"></a>&#x670D;&#x52A1;&#x5668;&#x7AEF;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候用startService什么时候用bindService"><span class="toc-text"><a href="#&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;startService&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;bindService" class="headerlink" title="&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;startService&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;bindService?"></a>&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;startService&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x7528;bindService?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于IntentService"><span class="toc-text"><a href="#&#x5173;&#x4E8E;IntentService" class="headerlink" title="&#x5173;&#x4E8E;IntentService"></a>&#x5173;&#x4E8E;IntentService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于service的生命周期"><span class="toc-text"><a href="#&#x5173;&#x4E8E;service&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;" class="headerlink" title="&#x5173;&#x4E8E;service&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;"></a>&#x5173;&#x4E8E;service&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;</span></a></li></ol></li></ol>
    </div>

        <blockquote>
<p>Android的四大组件之一，Android最默默无闻的组件，我觉得也是最难掌握的一个组件，自己了解的不是很好，所以在这纯搬运了大佬的文章。</p>
</blockquote>
<h2 id="第一篇讲了service的创建和两种启动方法"><a href="#第一篇讲了service的创建和两种启动方法" class="headerlink" title="第一篇讲了service的创建和两种启动方法"></a>第一篇讲了service的创建和两种启动方法</h2><p>附上链接<br><a href="https://blog.csdn.net/luoyanglizi/article/details/51586437" target="_blank" rel="noopener"> Android中的Service：默默的奉献者 (1)</a></p>
<h2 id="使用bindservice启动时的细节实现"><a href="#使用bindservice启动时的细节实现" class="headerlink" title="使用bindservice启动时的细节实现"></a>使用bindservice启动时的细节实现</h2><p>附上链接<br><a href="https://blog.csdn.net/luoyanglizi/article/details/51594016" target="_blank" rel="noopener">Android中的Service：Binder，Messenger，AIDL（2） </a></p>
<h2 id="将我的一些困惑和理解写在下面"><a href="#将我的一些困惑和理解写在下面" class="headerlink" title="将我的一些困惑和理解写在下面"></a>将我的一些困惑和理解写在下面</h2><h3 id="关于Service的实例化"><a href="#关于Service的实例化" class="headerlink" title="关于Service的实例化"></a>关于Service的实例化</h3><p>当我们用下面代码启动一个服务时，如果在实例化一个启动该Service的Intent，并再次调用startService，则这个服务不会再被创建，即不会再执行onCreate,只会调用onStartCommand。onCreate在第一次调用startService之后被调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,service.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure></p>
<p>停止服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(intent);</span><br></pre></td></tr></table></figure></p>
<h4 id="onBinder的用法"><a href="#onBinder的用法" class="headerlink" title="onBinder的用法"></a>onBinder的用法</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>客户端原则上来讲调用bindService()方法就可以了，然而事实并没有这么简单。原因就出在bindService()这个方法身上。下面我们来详细的了解一下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以看到，bindService()方法需要三个参数，第一个是一个intent，我们都很熟悉——它和startService()里面那个intent是一样的，用来指定启动哪一个service以及传递一些数据过去。第二个参数可能就有点陌生了，这是个啥？这是实现客户端与服务端通信的一个关键类。要想实现它，就必须重写两个回调方法：onServiceConnected()以及onServiceDisconnected()，而我们可以通过这两个回调方法得到服务端里面的IBinder对象，从而达到通信的目的(下文对此会有更加详细的介绍)。下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ServiceDemo mService;</span><br><span class="line"><span class="comment">//BinderDemo是在ServiceDemo里面的一个继承了Binder的内部类，这是一种得到IBinder接口的方式</span></span><br><span class="line"><span class="comment">//下文会有详述</span></span><br><span class="line">ServiceDemo.BinderDemo mBinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当系统调用 onServiceConnected() 回调方法时，我们可以使用接口定义的方法开始调用服务。</span></span><br><span class="line">        mBinder = (ServiceDemo.BinderDemo) service;</span><br><span class="line">        <span class="comment">//getService()是BinderDemo中的一个方法</span></span><br><span class="line">        mService = mBinder.getService();</span><br><span class="line">        <span class="comment">//在此处可以利用得到的ServiceDemo对象调用该类中的构造方法</span></span><br><span class="line">        Log.d(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"onServiceConnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Android系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“绝对不会”调用该方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"onServiceDisconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子实现了一个比较普通的ServiceConnection的主要功能，我们可以通过它得到目标service的对象，然后可以调用其内的共有方法，实现客户端与服务端交互的目的。</p>
<p>bindService()方法的第三个参数是一个int值，还叫flag(这flag立的)，它是用来做什么的呢？它是一个指示绑定选项的标志，通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的服务。 其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。</p>
<p>ok，客户端的配置到这里就差不多搞定了，接下来看看服务端需要做些什么。</p>
<h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><blockquote>
<p>如果要创建一个支持绑定的service，我们必须要重写它的onBind()方法。这个方法会返回一个IBinder对象，它是客户端用来和服务器进行交互的接口。而要得到IBinder接口，我们通常有三种方式：继承Binder类，使用Messenger类，使用AIDL。</p>
</blockquote>
<p><strong>1 继承Binder类</strong><br>它实现了IBinder接口，通过实现Binder类，我们的客户端可以直接通过这个类调用服务端的公有方法。另外，虽然从IPC的角度来讲，Binder是Android中的一种跨进程通信方式，但是其实一般service里面的Binder是不会涉及进程间通信的，所以其在这种情况下显得较为简单。</p>
<p>下面我们来看下通过继承Binder类实现客户端与服务端通信应该怎样做：</p>
<ul>
<li>在service类中，创建一个满足以下任一要求的Binder实例：<ul>
<li>包含客户端可调用的公共方法</li>
<li>返回当前Service实例，其中包含客户端可调用的公共方法</li>
<li>返回由当前service承载的其他类的实例，其中包含客户端可调用的公共方法</li>
</ul>
</li>
<li>在onBind()方法中返回这个Binder实例</li>
<li>在客户端中通过onServiceDisconnected()方法接收传过去的Binder实例，并通过它提供的方法进行后续操作</li>
</ul>
<p>可以看到，在使用这种方法进行客户端与服务端之间的交互是需要有一个强制类型转换的——在onServiceDisconnected()中获得一个经过转换的IBinder对象，我们必须将其转换为service类中的Binder实例的类型才能正确的调用其方法。而这强制类型转换其实就隐含了一个使用这种方法的条件：客户端和服务端应当在同一个进程中！不然在类型转换的时候也许会出现问题——在另一个进程中一定有这个Binder实例么？没有的话就不能完成强制类型转换。</p>
<p>下面是一个Google官方的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random mGenerator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class used for the client Binder.  Because we know this service always</span></span><br><span class="line"><span class="comment">     * runs in the same process as its clients, we don't need to deal with IPC.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Return this instance of LocalService so clients can call public methods</span></span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么时候用startService什么时候用bindService"><a href="#什么时候用startService什么时候用bindService" class="headerlink" title="什么时候用startService什么时候用bindService?"></a>什么时候用startService什么时候用bindService?</h3><p>这个其实可以通过它们的特点很轻松的得到结论：它们之间的主要区别其实体现在两点，能否交互，以及生命周期。所以很显然的，startService适合那种启动之后不显式停止它就永远在后台运行，并且不需要客户端与服务端交互的service。比方说一条专门拿来存数据到本地数据库的service，它就一直在后台等着有别的组件startService，然后把拿到的数据存入数据库，这就显然是用startService做的事情。而bindService呢，就适合那种可以交互的，可以掌控它什么时候停什么时候开始的。另外，如果有IPC的需求，那当然bindService是必不可少的了。</p>
<p>我们在上一篇博文里讲过，其实在大多数情况下，startService和bindService都是相辅相成的，它们并不是孤立的存在。比方说我这个时候要做一个音乐播放器，那么后台播放是肯定要的吧？总不能手机一熄屏音乐也没了。另外，控制音乐也是要的吧？什么上一首下一首播放暂停什么的。这不就强强联合了么？当然要注意的是，在这两种启动方式同时存在去启动一个service的时候，service的生命周期会发生变化，必须从两种方法的角度看service均停止才能真正停止。</p>
<h3 id="关于IntentService"><a href="#关于IntentService" class="headerlink" title="关于IntentService"></a>关于IntentService</h3><p><a href="https://blog.csdn.net/iromkoear/article/details/63252665" target="_blank" rel="noopener">IntentService详解</a></p>
<h3 id="关于service的生命周期"><a href="#关于service的生命周期" class="headerlink" title="关于service的生命周期"></a>关于service的生命周期</h3><p> 如果是通过startService方法启动的服务，如果不在内部调用stopself或者不在外部调用stopService，只有当启动该服务的进程终止时，该服务才会结束。</p>
<p>如果通过bindService启动服务，可以通过unbindService方法解绑服务，服务即停止，或者当bindService的组件销毁时，该服务就会停止。</p>
<p><img src="/2018/03/31/service/lifecircle.png" alt="看图"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2018-03-27T10:52:56.000Z"><a href="/2018/03/27/sort/">2018-03-27</a></time>
        
  
    <h1 class="title"><a href="/2018/03/27/sort/">排序算法</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-选择排序"><span class="toc-text"><a href="#1-&#x9009;&#x62E9;&#x6392;&#x5E8F;" class="headerlink" title="1 &#x9009;&#x62E9;&#x6392;&#x5E8F;"></a>1 &#x9009;&#x62E9;&#x6392;&#x5E8F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-直接插入排序"><span class="toc-text"><a href="#2-&#x76F4;&#x63A5;&#x63D2;&#x5165;&#x6392;&#x5E8F;" class="headerlink" title="2 &#x76F4;&#x63A5;&#x63D2;&#x5165;&#x6392;&#x5E8F;"></a>2 &#x76F4;&#x63A5;&#x63D2;&#x5165;&#x6392;&#x5E8F;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-希尔排序"><span class="toc-text"><a href="#3-&#x5E0C;&#x5C14;&#x6392;&#x5E8F;" class="headerlink" title="3 &#x5E0C;&#x5C14;&#x6392;&#x5E8F;"></a>3 &#x5E0C;&#x5C14;&#x6392;&#x5E8F;</span></a></li></ol>
    </div>

        <blockquote>
<p>今天参加图聚智能的笔试，有一题问快排算法，时间复杂度等等，根本全忘了，自己果然很菜。今天复习一下及几种排序算法。</p>
</blockquote>
<p>先来个总结：</p>
<p><img src="/2018/03/27/sort/图片.png" alt=""></p>
<p>以下例子的通用代码</p>
<p>交换位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	    Comparable swap = a[i];</span><br><span class="line">	    a[i] = a[j];</span><br><span class="line">	    a[j] = swap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找出小的那一个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1 选择排序"></a>1 选择排序</h2><p>思路：</p>
<blockquote>
<p>将第i个元素与i右边最小的元素交换位置，即先找出i右边（未排序）的最小值(包括i)，再交换位置。</p>
</blockquote>
<p>Java实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> N = a.length;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//min来记录最小值的位置</span></span><br><span class="line">	        <span class="keyword">int</span> min = i;</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">	        &#125;</span><br><span class="line">	        exch(a, i, min);</span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ol>
<li>运行时间和输入无关，无论输入是已排序，时间复杂度都是O(n^2)</li>
<li>数据移动最少，交换的次数和数组大小是线性关系</li>
</ol>
<h2 id="2-直接插入排序"><a href="#2-直接插入排序" class="headerlink" title="2 直接插入排序"></a>2 直接插入排序</h2><p>思路：</p>
<blockquote>
<p>在第i次迭代时，将第i个元素与左边每一个比它大的交换位置</p>
</blockquote>
<p>Java实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特点：</p>
<ol>
<li>运行时间和输入有关，当输入已排序时，时间复杂度是O(n);</li>
<li>交换的次数等于输入中倒置(inversion)的个数</li>
<li>插入排序适合部分有序数组，也适合小规模数组</li>
</ol>
<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3 希尔排序"></a>3 希尔排序</h2><p>希尔排序基于插入排序</p>
<p>思路：</p>
<blockquote>
<p>选取一个增量d，一般是总个数的一半，每次减半<br>将距离为d的倍数的元素放到一组，对组内进行直接插入排序<br>减半增量，直到增量为1，完成排序</p>
</blockquote>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
 
<nav id="pagination">
  
    <a href="/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/3/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
      <aside id="sidebar" class="alignright">
        
           

        
          <div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/qrcode.jpg" alt="欢迎关注个人公众账号" style= "width: 100%">
    </ul>
</div>
        
          <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>

        
          
  <div class="widget tag">
    <h3 class="title">友情链接</h3>
      <ul class="entry">
        
          <li class='link'><a href='http://xiaoyun.farbox.com'>晓晓博客</a></li>
        
          <li class='link'><a href='http://www.ituring.com.cn/users/136808'>图灵社区</a></li>
        
      </ul>
  </div>


        
          
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">公元 2018 年</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">11</span></li></ul>
  </div>

        
      </aside>
      <div class="clearfix"></div>
    </div>
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2018 Sunday
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>

  <div>
    Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:, root:'calendar'});
    
    });
  </script>


<!-- 百度统计 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>